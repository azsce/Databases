---
title: "3. chapter 3"
---


# Data Modeling Using the Entity-Relationship (ER) Model

Alright everyone, welcome. Today, we embark on a crucial topic: **Chapter 3, Data Modeling Using the Entity-Relationship Model**, or as we commonly call it, the ER Model. This chapter forms the bedrock of how we conceptualize and design databases. We'll be learning the language and the diagrams that allow us to translate real-world information into a structured format that a database system can understand. So, let's dive in.

<div class="page-break"></div>

### Chapter Outline

Now, let's take a look at our roadmap for this chapter. We'll begin with an **Overview of the Database Design Process**, to understand where ER modeling fits into the bigger picture.

Then, to make things concrete, we'll work with an **Example Database Application**, which we'll call the **COMPANY** database. This will be our running example throughout.

The core of our discussion will revolve around **ER Model Concepts**. Here, we'll break down the fundamental building blocks:
*   First, **Entities and Attributes**. What are they? How do we define them?
*   We'll then delve deeper into **Entity Types, Value Sets, and Key Attributes** – crucial for uniquely identifying entities.
*   Next, we'll explore **Relationships and Relationship Types**, which define how different entities interact.
*   A special case, **Weak Entity Types**, will be examined, along with how they are identified.
*   And, we'll also look at **Roles and Attributes in Relationship Types**.

Once we have a grasp of these concepts, we'll learn about **ER Diagrams - Notation**. This is where we visually represent our models. We'll then apply this by creating an **ER Diagram for our COMPANY Schema**.

To broaden our perspective, we'll touch upon **Alternative Notations**, including UML class diagrams, which you might encounter in other contexts.

And finally, we'll consider **Relationships of Higher Degree** – going beyond simple binary relationships.

It’s a comprehensive journey, but a very important one. Shall we begin?

<div class="page-break"></div>

### Overview of Database Design Process

So, when we talk about creating a database system, there are broadly **two main activities** we need to consider.

*   First, there's **Database design**. This is all about structuring the data itself. What data do we need to store? How is it related? How do we ensure its integrity?
*   Second, there's **Applications design**. This focuses on creating the programs and interfaces that users will interact with to access and manipulate the data stored in the database. Think of the software that sits on top of the database.

Now, our **focus in this chapter**, and indeed in much of this course, is on **conceptual database design**.
*   The primary goal here is **to design the conceptual schema for a database application**. This conceptual schema is like a high-level blueprint of our database, capturing the entities, their attributes, and the relationships among them, independent of any specific database management system.

Just to clearly delineate, **Applications design**, which involves creating those user-facing programs and interfaces, is generally considered part of the broader field of **software engineering**. While related and very important, our immediate concern is the foundational data structure.

---

### Overview of Database Design Process (Diagram)

**Figure 3.1** A simplified diagram to illustrate the main phases of database design.

Let's look at this diagram, Figure 3.1. It provides a simplified, yet very illustrative, overview of the database design process.

It all starts with the **Miniworld** – that is, the part of the real world that we are interested in modeling and storing information about in our database.

From this Miniworld, the first phase is **Requirements Collection and Analysis**. Here, we gather all the necessary information – what data needs to be stored, what operations will be performed, any constraints, and so on. This phase yields two main outputs:
*   **Functional Requirements**, which describe the operations and transactions that will be run on the database.
*   And, critically for us, **Data Requirements**, which detail the information that needs to be stored.

The Data Requirements feed directly into **Conceptual Design**. This is where we use a high-level data model, like the ER model we're about to study, to create a **Conceptual Schema**. This schema is still quite abstract and independent of any particular Database Management System (DBMS).

Parallel to this, the Functional Requirements go into **Functional Analysis**, leading to a **High-Level Transaction Specification** – basically, what the database needs to *do*.

Now, notice the dotted line. Above it, we are largely in a **DBMS-independent** world.
Below it, we become **DBMS-specific**.

The Conceptual Schema is then transformed during **Logical Design**, also known as Data Model Mapping. Here, we map our conceptual schema into the data model of a specific DBMS – for example, the relational model. This results in the **Logical (Conceptual) Schema** in the data model of that chosen DBMS.

Finally, the Logical Schema undergoes **Physical Design**, where we decide how the data will actually be stored on physical storage devices. This yields the **Internal Schema**.

On the application side, the High-Level Transaction Specification, combined with the Logical Schema, informs the **Application Program Design**, which leads to **Transaction Implementation**, resulting in the actual **Application Programs** that interact with the database.

This entire process ensures we move methodically from a general understanding of the Miniworld to a fully implemented database system. Our focus, again, is primarily on that crucial Conceptual Design phase.

<div class="page-break"></div>

### Methodologies for Conceptual Design

Now that we understand *where* conceptual design fits, let's talk about *how* we do it. There are several established methodologies and tools.

*   The primary one we'll be focusing on in **this chapter** are **Entity Relationship (ER) Diagrams**. This is a widely used graphical notation for representing the conceptual schema.
*   In **Chapter 4**, we'll look at **Enhanced Entity Relationship (EER) Diagrams**, which extend the basic ER model with more advanced concepts like specialization and generalization.
*   In industry, for designing and documenting large-scale designs, the **Use of Design Tools** is prevalent. These CASE (Computer-Aided Software Engineering) tools often implement ER or EER modeling and help manage complex schemas.
*   And, another very popular approach, particularly in the context of object-oriented design but also applicable to database design, is **The UML (Unified Modeling Language) Class Diagrams**. These are frequently used in industry to document conceptual database designs, and we'll see how they relate to ER diagrams later in this chapter.

So, while ER diagrams are our main tool for now, it's good to be aware of the broader landscape.

<div class="page-break"></div>

### Example COMPANY Database

Alright, to make our discussion of ER modeling practical and easy to follow, we need an example. So, **we need to create a database schema design** based on a set of simplified requirements for what we'll call the **COMPANY Database**. This will be our case study.

Let's look at the initial requirements:

*   First, the company is organized into **DEPARTMENTS**.
    *   Each department has a **name**, a **number**, and an **employee who *manages*** the department.
    *   We also need to keep track of the **start date** of the department manager.
    *   And, a department may have **several locations**.

*   Second, each department **controls a number of PROJECTs**.
    *   Each project has a **unique name**, a **unique number**, and is **located at a single location**.

These are the first pieces of information about our "miniworld"—the COMPANY—that we'll need to model. We'll build on these requirements as we go.

---

### Example COMPANY Database (Continued)

Let's continue with the requirements for our COMPANY Database.

*   The database will store information about each **EMPLOYEE**. Specifically:
    *   Their **social security number**, **address**, **salary**, **sex**, and **birthdate**.
    *   Now, regarding their work: Each employee ***works for*** **one department**, but importantly, they may ***work on*** **several projects**.
    *   The database also needs to keep track of the **number of hours per week** that an employee currently works on each project.
    *   And, it's required to keep track of the **direct *supervisor*** of each employee. This implies a relationship between employees themselves.

*   Finally, each employee may ***have*** a number of **DEPENDENTs**.
    *   For each dependent, the database keeps a record of their **name, sex, birthdate, and their relationship to the employee** (e.g., son, daughter, spouse).

These details provide us with a rich set of information to model, including different types of entities and the various ways they are interconnected. Keep these requirements in mind as we start to define ER model concepts.

<div class="page-break"></div>

### ER Model Concepts: Entities and Attributes

Now, we begin to lay the groundwork for the Entity-Relationship model itself. At the very heart of this model are two fundamental concepts: **Entities** and **Attributes**.

*   First, let's define an **Entity**.
    *   An **Entity** is a core, basic concept within the ER model. You can think of entities as **specific, distinguishable things or objects in the mini-world** – the slice of reality we're interested in – that we want to represent and store data about in our database. They are the "nouns," the principal objects of interest.
    *   For instance, in a university setting, a particular student, say `STUDENT Alice Wonderland`, would be an entity. A specific course, like the `COURSE Introduction to Databases`, is an entity. A particular department, such as the `Mathematics DEPARTMENT`, is also an entity. These are all distinct and identifiable items.

*   Next, we have **Attributes**.
    *   **Attributes** are the **properties or characteristics that are used to describe an entity**. They provide the details and descriptive information *about* our entities.
    *   For example, for a `STUDENT` entity like Alice Wonderland, attributes might include `StudentID`, `Name`, `Major`, `EnrollmentDate`, and `EmailAddress`.

*   A key understanding is that **a specific entity will possess a value for each of its defined attributes**.
    *   So, for our specific `STUDENT` entity, Alice Wonderland, the attribute values might be something like:
        *   `StudentID = 'S1001'`
        *   `Name = 'Alice Wonderland'`
        *   `Major = 'Computer Science'`
        *   `EnrollmentDate = '01-SEP-2022'`
        *   `EmailAddress = 'alice.w@example.edu'`

*   Finally, **each attribute has a value set (or data type) associated with it**. This defines the kind of data that can be stored in that attribute.
    *   For example, `StudentID` might be a string of characters, `EnrollmentDate` would be of a date type, `GPA` (if we had it) might be a numeric type, and `Major` could be a string or perhaps an enumerated type if there's a fixed list of majors.

So, entities are the "things," and attributes are their "descriptions." This fundamental pairing is what we build upon to create rich and meaningful database models.


<div class="page-break"></div>

### Types of Attributes (1)

Now that we understand what attributes are, let's explore their different types. Attributes aren't all the same; they can be categorized based on their structure and the values they can hold.

First, we have **Simple Attributes**.
*   These are attributes where each entity has a **single atomic value** for the attribute. "Atomic" here means it cannot be further subdivided into meaningful components.
    *   For example, `SSN` (Social Security Number) for an employee is typically a simple attribute. Similarly, `Sex` (e.g., M or F) is a simple attribute.

Next, we have **Composite Attributes**.
*   A composite attribute is one that **may be composed of several components**, each of which can be a simple attribute or even another composite attribute.
    *   A classic example is `Address`. An address can be broken down into `Apt#`, `House#`, `Street`, `City`, `State`, `ZipCode`, and `Country`.
    *   Another common example is `Name`, which can be composed of `FirstName`, `MiddleName`, and `LastName`.
    *   Importantly, **composition may form a hierarchy**, where some components are themselves composite. For instance, a `StreetAddress` component of `Address` could itself be composite.

Then, there are **Multi-valued Attributes**.
*   For a multi-valued attribute, an entity **may have multiple values for that attribute**.
    *   Consider the `Color` of a CAR. A car can be two-tone, so it might have multiple colors, say, red and black.
    *   Another example could be `PreviousDegrees` of a STUDENT, as a student might hold multiple degrees from different institutions.
*   We typically denote multi-valued attributes using curly braces. So, `{Color}` or `{PreviousDegrees}`.

You can see a small diagram on the top right illustrating a `CAR` entity. `Year`, `Make`, and `Model` appear to be simple attributes. `Color` is shown as a multi-valued attribute (often depicted with a double oval, though not explicitly here). `Registration` is a composite attribute, composed of `State` and `Number`, and it's also marked as a key, which we'll discuss soon. `Vehicle_id` is another key attribute.

Understanding these distinctions is crucial for accurately modeling the data.

---

### Types of Attributes (2)

Let's continue our discussion on the types of attributes, specifically how composite and multi-valued attributes can interact.

*   In general, **composite and multi-valued attributes may be nested arbitrarily to any number of levels**, although in practice, very deep nesting is rare as it can complicate the model.

*   Let's consider an example. Imagine a `STUDENT` entity and we want to store their `PreviousDegrees`.
    *   `PreviousDegrees` is inherently **multi-valued** because a student can have more than one previous degree.
    *   Furthermore, each degree itself has several components: the `College` they attended, the `Year` they graduated, the `Degree` name (e.g., BS, MS), and the `Field` of study.
    *   So, `PreviousDegrees` of a STUDENT is a **composite multi-valued attribute**. We would denote this as:
        `{PreviousDegrees (College, Year, Degree, Field)}`.

*   This means that for a single student, **multiple `PreviousDegrees` values can exist**.
*   And **each** of these `PreviousDegrees` values has **four subcomponent attributes**: `College`, `Year`, `Degree`, and `Field`.

The diagram at the top right, showing the `CAR` entity, is the same as on the previous slide, just for context. The key takeaway here is the flexibility the ER model provides for representing complex attribute structures.

---

### Example of a composite attribute

Let's look at a clearer, more detailed visual example of a **composite attribute**.

Here we see the attribute **Address**.
This `Address` attribute is shown as being composed of several distinct components:
*   `Street_address`
*   `City`
*   `State`
*   `Zip`

Furthermore, the component `Street_address` is *itself* a composite attribute. It is further broken down into:
*   `Number` (e.g., the house or building number)
*   `Street` (e.g., the street name)
*   `Apartment_number`

This hierarchical breakdown illustrates how a composite attribute can have components that are also composite. `City`, `State`, and `Zip` in this particular diagram are shown as simple attributes, as are `Number`, `Street`, and `Apartment_number`.

Again, the small `CAR` entity diagram is on the top right for reference, but our focus here is the `Address` structure. This ability to represent such structured attributes is a powerful feature of the ER model, allowing us to capture the nuances of real-world data.

---

Okay, class, let's move on to how we group these entities and identify them. This brings us to **Entity Types and Key Attributes**.

<div class="page-break"></div>

### Entity Types and Key Attributes (1)

Now that we understand individual entities and their attributes, we need a way to talk about *collections* of similar entities. This leads us to the concept of an **Entity Type**.

*   Think of it this way: **Entities that share the same basic attributes are grouped or "typed" into an entity type**. An entity type serves as a template or a blueprint for a set of entities. It defines the common structure – the set of attributes – that all entities of that type will possess.
    *   For example, in our COMPANY database, all individual employee entities (like John Smith, Mary Jones, etc.) would belong to the **entity type `EMPLOYEE`**. Similarly, all specific project entities (ProductX, ProjectY) would belong to the **entity type `PROJECT`**.
    The entity type `EMPLOYEE` would define attributes common to all employees, such as `Name`, `SSN`, `Address`, etc.

*   Now, within an entity type, how do we distinguish one specific entity from another? This is where **Key Attributes** come into play.
    *   An **attribute of an entity type for which each entity must have a unique value is called a key attribute** of that entity type. Its primary purpose is to uniquely identify each entity instance within its entity set.
    *   For example, for the `EMPLOYEE` entity type, the `SSN` (Social Security Number) is a very good candidate for a key attribute. We expect every employee to have an SSN, and each SSN should be unique across all employees. This allows us to pinpoint exactly one employee record if we know their SSN.

So, entity types provide the classification, and key attributes provide the unique identification within that classification. These are fundamental concepts for organizing and retrieving data effectively.

---

**(Slide 14: Entity Types and Key Attributes (2))**

"Continuing our discussion on keys… it's important to understand that a **key attribute** isn't always a single, simple attribute. Sometimes, a key can be **composite**. This means the key is formed by a combination of two or more attributes. The slide offers a good example: 'VehicleTagNumber' for a 'CAR' entity type. This key could be composed of 'Number' (the license plate number itself) and 'State' (the issuing state). Neither 'Number' nor 'State' alone might be unique across all cars, but their combination is.

Furthermore, an entity type isn't restricted to having just one key. It's quite possible for an **entity type to have more than one key**. Each of these is called a *candidate key*. For our 'CAR' entity type, we might have two distinct keys: the 'VehicleIdentificationNumber', commonly known as the VIN, which is globally unique. And, as we just discussed, the 'VehicleTagNumber', which is the combination of (Number, State), also serving as a license plate number. Both VIN and VehicleTagNumber can uniquely identify a car.

A crucial point regarding notation in ER diagrams: **each key attribute is underlined**. This is a visual cue to help us identify the keys. Now, be mindful: this convention in ER modeling is slightly different from what you might see in relational schemas later on, where typically only *one* key, designated as the 'primary key', is underlined. In the ER model, *all* candidate keys are underlined. This distinction is important to remember as we move between conceptual modeling and logical database design."

---

**(Slide 15: Entity Set)**

"Let's now clarify the distinction between an 'entity type' and an 'entity set'. While an **entity type**, as we've discussed, is the *schema* or the *blueprint* – for example, the definition of what a 'CAR' is with its attributes like Vehicle ID, Make, Model, and Color – an **entity set** refers to the *actual collection* of entities of that type that are stored in the database at any given moment.

So, if 'CAR' is our entity type, the entity set for 'CAR' would be all the specific car instances currently recorded in our database. The slide cleverly illustrates this. You see the ER diagram for the 'CAR' entity type at the top, defining its structure and attributes, including its keys like 'Registration' (composed of State and Number) and 'Vehicle_id', and even a multivalued attribute 'Color'.

The previous slide, not shown here but referenced, would have depicted specific instances – say, three different CAR entities – which collectively form part of the entity set for CAR.

It's common practice, as the slide points out, to use the **same name** – in this case, 'CAR' – to refer to both the entity type (the definition) and the entity set (the collection of instances). However, it's also possible, though less common, to give them distinct names if clarity demands it.

Crucially, the **entity set represents the *current state*** of the entities of that type. As cars are added to or removed from our database, the entity set for 'CAR' changes. It's a dynamic collection, reflecting the real-world information we're modeling."

---

**(Slide 16: Value Sets (Domains) of Attributes)**

"Every attribute we define for an entity type is associated with what we call a **value set**, or sometimes, a **domain**. This concept is fundamental because it specifies the *kind* of data and the *range* of permissible values an attribute can hold.

Consider a simple attribute. Each simple attribute, like 'Lastname' for an EMPLOYEE, will have a value set. For 'Lastname', the value set might be defined as 'a character string of up to 15 characters'. This means any value assigned to 'Lastname' must conform to this definition.

Another example given is a 'Date' attribute. Its value set might be defined to consist of values in the 'MM-DD-YYYY' format, where each letter represents an integer. This ensures consistency in how dates are stored and interpreted.

So, in essence, a **value set** acts as a constraint, specifying the **set of all possible values** that can be legitimately associated with a particular attribute. This is crucial for data integrity and consistency within our database."

---

**(Slide 17: Displaying an Entity type)**

"Now, let's talk about how we visually represent these concepts in an Entity-Relationship diagram, or ER diagram. Understanding the notation is key to reading and creating these models.

First, an **entity type** itself is displayed prominently within a **rectangular box**. So, if we have an entity type like 'CAR', it will appear inside a rectangle.

Next, its **attributes are displayed in ovals**. Each of these ovals is then connected by a line to the rectangular box of its entity type.

If an attribute is **composite**, meaning it's made up of several components – like 'Address' being composed of 'Street', 'City', 'State', and 'Zip' – the components themselves are also shown in ovals, connected to the oval that represents the main composite attribute.

As we've learned, **key attributes** are special, and they are distinguished by being **underlined** within their oval. This immediately tells us which attributes can uniquely identify an entity.

And for **multivalued attributes** – those that can hold multiple values for a single entity, like 'Color' for a CAR (a car can be red *and* black) – these are displayed in **double ovals**.

The slide mentions that the full ER notation will be shown on the next slide, which will give us a comprehensive legend. For now, this diagram of the 'CAR' entity type with its attributes like 'Registration' (a composite key), 'Vehicle_id' (a key), and 'Color' (multivalued) serves as a good initial illustration of these conventions."

---

**(Slide 18: NOTATION for ER diagrams)**

"This slide provides a very useful summary – a legend, if you will – of the **standard notation used in ER diagrams**. It's essential to become familiar with these symbols as they form the visual language of conceptual database design. Let's quickly go through them, as depicted in Figure 3.14.

*   A simple **Rectangle** represents an **Entity type**.
*   A **Double Rectangle** signifies a **Weak Entity type**, which we'll discuss in more detail later. These entities depend on another entity for their identification.
*   A **Diamond shape** is used to denote a **Relationship type** between entities.
*   A **Double Diamond** indicates an **Identifying Relationship type**, typically associated with weak entities.
*   An **Oval** represents an **Attribute**.
*   An **Oval with underlined text** clearly marks a **Key Attribute**.
*   A **Double Oval** is the symbol for a **Multivalued Attribute**.
*   An **Oval connected to other ovals** depicts a **Composite Attribute**, showing its constituent parts.
*   A **Dashed Oval** represents a **Derived Attribute** – one whose value can be calculated from other attributes.

The diagram also shows notation for relationship constraints:
*   A line connecting two entities, E1 and E2, through a relationship R, where the line to E2 is a **double line**, signifies **Total Participation** of E2 in R. This means every entity in E2 *must* participate in the relationship R.
*   Cardinality Ratios, like **1:N (one-to-many)**, are indicated by placing '1' and 'N' on the lines connecting the entities E1 and E2 to the relationship R, respectively.
*   Finally, **Structural Constraints**, often expressed as **(min, max) pairs**, can be shown on the participation line of an entity E in a relationship R. This specifies the minimum and maximum number of times an entity E can participate in relationship R.

This legend is your go-to reference for interpreting and constructing ER diagrams."

---

**(Slide 19: Entity Type CAR with two keys and a corresponding Entity Set)**

"Let's solidify our understanding with Figure 3.7, which beautifully illustrates both the **ER diagram notation** for an entity type and an example of its corresponding **entity set**.

Part **(a)** of the figure shows the ER diagram for the 'CAR' entity type. Notice:
*   'CAR' is in a rectangle.
*   It has two key attributes, both underlined:
    *   'Registration', which is a *composite* key made up of 'Number' and 'State'.
    *   'Vehicle_id', a simple key attribute.
*   Other attributes like 'Make', 'Model', and 'Year' are shown in single ovals.
*   And 'Color' is in a *double oval*, indicating it's a multivalued attribute – a car can have multiple colors.

Part **(b)** then gives us a glimpse into the **entity set** for 'CAR'. This is a textual representation of some actual CAR instances that might exist in the database.
*   You can see `CAR₁` with its specific values: Registration is ('ABC 123', 'TEXAS'), Vehicle_id is 'TK629', it's a Ford Mustang convertible, year 2004, and its colors are red, black.
*   Similarly, `CAR₂` and `CAR₃` are distinct instances with their own attribute values. For example, `CAR₃` has colors white, blue.
*   The colon (`:`) indicates that there are more such instances in the entity set.

This slide effectively bridges the gap between the abstract definition (the entity type in the ER diagram) and the concrete data (the entity set)."

---

**(Slide 20: Example COMPANY Database)**

"Now, we're going to start applying these concepts to a practical scenario. We need to design a database schema for a hypothetical 'COMPANY'. This slide begins to lay out the **simplified requirements** for this COMPANY Database. Understanding these requirements is the very first step in database design.

Let's break down the first set of requirements:

*   First, 'The company is organized into **DEPARTMENTS**.' This immediately suggests 'DEPARTMENT' as a potential entity type.
*   'Each department has a **name**, **number**...' – these sound like attributes of DEPARTMENT. It's also likely that 'name' or 'number', or perhaps both, could serve as keys.
*   '...and an employee who **manages** the department.' This hints at a relationship, perhaps called 'MANAGES', between an 'EMPLOYEE' entity type (which we'll likely define soon) and the 'DEPARTMENT' entity type.
*   'We keep track of the **start date** of the department manager.' This 'start date' could be an attribute of the 'MANAGES' relationship itself, as it describes when a particular employee began managing a particular department.
*   'A department may have several **locations**.' 'Locations' sounds like a multivalued attribute for DEPARTMENT, as one department can be in multiple places.

Next requirement:
*   'Each department **controls** a number of **PROJECTs**.' This clearly indicates another entity type, 'PROJECT', and a relationship, 'CONTROLS', between 'DEPARTMENT' and 'PROJECT'.
*   'Each project has a unique **name**, unique **number**...' – attributes for PROJECT, and potential keys.
*   '...and is located at a **single location**.' This 'location' would be a simple attribute for PROJECT.

These initial requirements give us a strong starting point for identifying our main entities and some of their attributes and interconnections."

---

**(Slide 21: Example COMPANY Database (Continued))**

"Let's continue with the requirements for our COMPANY Database.

*   The next point states: 'The database will store each **EMPLOYEE's social security number, address, salary, sex, and birthdate**.' This explicitly defines 'EMPLOYEE' as an entity type and lists several of its attributes. 'Social security number' (SSN) is a very strong candidate for a key attribute.

Now, we get into more details about employees and their relationships:
*   'Each employee **works for** one department...' This points to a 'WORKS_FOR' relationship between EMPLOYEE and DEPARTMENT. The phrase "one department" gives us a hint about the cardinality of this relationship – likely N:1 from employee to department.
*   '...but may **work on** several projects.' This suggests a 'WORKS_ON' relationship between EMPLOYEE and PROJECT. "Several projects" implies this could be an M:N (many-to-many) relationship, as an employee can work on multiple projects, and a project can have multiple employees.

*   'The DB will keep track of the **number of hours per week** that an employee currently works on each project.' This 'number of hours' is specific to a particular employee working on a particular project. Therefore, it's likely an attribute of the 'WORKS_ON' relationship itself.

*   'It is required to keep track of the **direct supervisor** of each employee.' This indicates a *recursive* relationship on the EMPLOYEE entity type. An employee (as a supervisor) supervises another employee (as a supervisee). We might call this relationship 'SUPERVISION'.

Finally, regarding dependents:
*   'Each employee may **have** a number of **DEPENDENTs**.' This introduces another entity type, 'DEPENDENT'. The relationship might be called 'HAS_DEPENDENTS' or 'DEPENDENTS_OF'.
*   'For each dependent, the DB keeps a record of **name, sex, birthdate, and relationship** to the employee.' These are attributes of the DEPENDENT entity type. 'Name' of the dependent might be a partial key, as it's likely unique only within the context of a specific employee. This suggests 'DEPENDENT' could be a weak entity type, dependent on 'EMPLOYEE'.

These requirements are rich with information that will guide our ER model design."

---

**(Slide 22: Initial Conceptual Design of Entity Types for the COMPANY Database Schema)**

"Having carefully analyzed the requirements on the previous slides, we can now make our **initial identification of the primary entity types** for the COMPANY database schema. This is a crucial first step in conceptual design.

Based on those requirements, we've identified four key entity types:

1.  **DEPARTMENT**: This came from the organization of the company and details about department management and control over projects.
2.  **PROJECT**: Derived from the need to track projects, their details, and which department controls them.
3.  **EMPLOYEE**: Clearly essential for storing information about the company's personnel, their roles, and assignments.
4.  **DEPENDENT**: Needed to keep track of the dependents of employees.

The **initial conceptual design** for these entity types, including some of their initially identified attributes, will be visually presented on the *next slide*.

It's important to remember that these **initial attributes are directly derived from the requirements description** we just went through. This design is 'initial' because, as we'll see, some of these attributes might later be refined into relationships, or we might discover new attributes or relationships as we iterate on the design."

---

**(Slide 23: Initial Design of Entity Types: EMPLOYEE, DEPARTMENT, PROJECT, DEPENDENT)**

"Here we see Figure 3.8, which presents the **preliminary design of our four initial entity types** for the COMPANY database: EMPLOYEE, DEPARTMENT, PROJECT, and DEPENDENT. This is our first attempt at structuring the data based on the requirements.

Let's examine each one:

*   For **DEPARTMENT**, we've listed attributes like 'Name' and 'Number' (both potential keys, perhaps underlined if we were finalizing keys at this stage, though the diagram doesn't show underlining yet). We also have 'Locations' (which we noted could be multivalued), 'Manager', and 'Manager_start_date'.

*   For **PROJECT**, we have 'Name' and 'Number' (again, potential keys), 'Location', and an attribute called 'Controlling_department', which hints at a link to the DEPARTMENT entity.

*   For **EMPLOYEE**, we see a composite 'Name' (Fname, Minit, Lname), 'Ssn' (a strong candidate for a primary key), 'Birth_date', 'Address', 'Sex', 'Salary'. Then, attributes like 'Department', 'Supervisor', and 'Works_on' (which itself looks composite, holding 'Project' and 'Hours'). These latter attributes – 'Department', 'Supervisor', 'Works_on', 'Manager' in DEPARTMENT, 'Controlling_department' in PROJECT – are prime candidates to be *refined into relationships* rather than remaining as simple attributes.

*   For **DEPENDENT**, we have 'Dependent_name' (likely a partial key), 'Sex', 'Birth_date', 'Relationship', and an attribute 'Employee' to link it back to the relevant employee.

The caption rightly notes that this is a **preliminary design**, and some of the shown attributes will indeed be refined into relationships as we develop a more complete ER model. This is a typical iterative process in database design."

---

**(Slide 24: Refining the initial design by introducing relationships)**

"As we just saw in the preliminary design, simply listing attributes within entities isn't always sufficient or the most accurate way to model the real world. The **initial design is typically not complete**.

Many aspects described in the requirements are better represented as **relationships** between entity types, rather than as attributes within a single entity type. For example, instead of 'Employee' having a 'Department' attribute, it's more semantically correct to say an 'Employee' *WORKS_FOR* a 'Department', where 'WORKS_FOR' is a relationship.

To understand how we refine this, let's recall the three main concepts of the ER model:

1.  **Entities** (and their entity types and entity sets): These are the 'things' or 'objects' we are modeling.
2.  **Attributes** (simple, composite, multivalued): These describe the properties of the entities.
3.  And, crucially for this step, **Relationships** (and their relationship types and relationship sets): These represent the associations or connections *between* entities.

So, our next step in refining the COMPANY database schema is to **introduce these relationship concepts explicitly**. We'll identify which of those initial 'linking' attributes should actually be modeled as distinct relationships connecting our entity types. This will lead to a more robust and semantically richer model."

---

**(Slide 25: Relationships and Relationship Types (1))**

"Let's formally define what we mean by **relationships** and **relationship types**.

A **relationship**, in the ER model, is an association that *relates two or more distinct entities* and carries a *specific meaning*. It's not just a line; it's a meaningful connection. For example, the statement 'EMPLOYEE John Smith *works on* the ProductX PROJECT' describes a specific relationship instance. Similarly, 'EMPLOYEE Franklin Wong *manages* the Research DEPARTMENT' is another relationship instance.

Now, just as we group similar entities into an entity type, we group similar relationships into a **relationship type**. A relationship type defines the schema for a set of associations. For example, all the 'works on' instances between employees and projects would belong to a 'WORKS_ON' relationship type. This 'WORKS_ON' relationship type would specify that it occurs between the 'EMPLOYEE' entity type and the 'PROJECT' entity type. Likewise, a 'MANAGES' relationship type would exist between 'EMPLOYEE' and 'DEPARTMENT'.

An important characteristic of a relationship type is its **degree**. The degree is simply the **number of participating entity types**.
In our examples, both 'MANAGES' (involving EMPLOYEE and DEPARTMENT) and 'WORKS_ON' (involving EMPLOYEE and PROJECT) are **binary relationships**, because they each involve two entity types. We can also have relationships of higher degrees, such as ternary (involving three entity types), which we'll touch upon later."

---

**(Slide 26: Relationship instances of the WORKS_FOR N:1 relationship between EMPLOYEE and DEPARTMENT)**

"This slide, Figure 3.9, provides an excellent visual representation of **relationship instances** within a **relationship set**. Specifically, it illustrates the 'WORKS_FOR' relationship type, which we identified as existing between the 'EMPLOYEE' and 'DEPARTMENT' entity types.

On the left, you see a set of ovals representing individual **EMPLOYEE entities** – e₁, e₂, e₃, and so on.
On the right, another set of ovals represents **DEPARTMENT entities** – d₁, d₂, d₃, etc.
In the middle, the larger oval labeled 'WORKS_FOR' contains the **relationship instances** – r₁, r₂, r₃, and so forth. Each 'r' instance here represents a specific employee working for a specific department.

Observe the connections:
*   r₁ connects e₁ to d₁. This means employee e₁ works for department d₁.
*   r₂ connects e₂ to d₁. This means employee e₂ *also* works for department d₁.
*   r₃ connects e₃ to d₂. Employee e₃ works for department d₂.

This diagram clearly depicts an **N:1 (many-to-one) relationship** from EMPLOYEE to DEPARTMENT. Why? Because multiple employees (e₁ and e₂, for instance) can work for the *same* department (d₁). However, if you trace from an employee, like e₁, it connects to *only one* department through a single relationship instance. This matches our requirement that 'Each employee works for one department'. Understanding these instance diagrams helps clarify the nature and constraints of relationships."

---

**(Slide 27: Relationship instances of the M:N WORKS_ON relationship between EMPLOYEE and PROJECT)**

"Here in Figure 3.13, we see another example of relationship instances, this time for the **'WORKS_ON' relationship type** that exists between 'EMPLOYEE' and 'PROJECT'. This one illustrates a different kind of cardinality.

Again, we have:
*   **EMPLOYEE entities** (e₁, e₂, e₃, e₄, ...) on the left.
*   **PROJECT entities** (p₁, p₂, p₃, p₄, ...) on the right.
*   The 'WORKS_ON' oval in the middle contains the **relationship instances** (r₁, r₂, r₃, ...).

Let's trace some connections:
*   r₁ links e₁ to p₁. Employee e₁ works on project p₁.
*   r₂ links e₂ to p₂. Employee e₂ works on project p₂.
*   Now, look at r₃: it links e₁ *also* to p₂. This means employee e₁ works on project p₂ *in addition* to project p₁. So, one employee can work on multiple projects.
*   And consider r₄ and r₅: r₄ links e₃ to p₃, and r₅ links e₄ *also* to p₃. This means project p₃ has multiple employees (e₃ and e₄) working on it.

This pattern – where an employee can be related to multiple projects, AND a project can be related to multiple employees – defines an **M:N (many-to-many) relationship**. This aligns with our requirement that an employee 'may work on several projects'. These instance diagrams are invaluable for visualizing such complex associations."

---

**(Slide 28: Relationship type vs. relationship set (1))**

"It's crucial to distinguish clearly between a **Relationship Type** and a **Relationship Set**, just as we did for entity types and entity sets.

A **Relationship Type** is essentially the **schema description** or the *blueprint* of a relationship.
*   It **identifies the name** of the relationship (e.g., 'WORKS_FOR', 'MANAGES').
*   It specifies the **participating entity types** (e.g., EMPLOYEE and DEPARTMENT participate in 'WORKS_FOR').
*   Importantly, it also **identifies certain relationship constraints**, such as cardinality ratios (like 1:1, 1:N, M:N) and participation constraints (whether an entity *must* participate or *can* participate). We'll delve deeper into constraints shortly.

On the other hand, a **Relationship Set** is the **current collection of actual relationship instances** that are represented in the database at a specific point in time.
*   It's the set of all specific connections that exist. For instance, all the individual 'employee works for department' links currently in the system.
*   Therefore, the relationship set represents the **current *state*** of a relationship type. Just like an entity set, a relationship set is dynamic and changes as relationships are created or removed in the database.

So, type is the definition; set is the collection of instances adhering to that definition."

---

**(Slide 29: Relationship type vs. relationship set (2))**

"Continuing our distinction, the **previous figures** we just looked at – the ones showing employees working for departments, and employees working on projects – were actually displaying **relationship sets**. They showed concrete instances of relationships.

Each **instance** in that set, like 'r₁' in the WORKS_FOR example, relates *individual participating entities* – specifically, one entity from each participating entity type (e.g., one employee instance and one department instance).

Now, when we move to **ER diagrams**, we are primarily representing the **relationship *type***, not the entire set of instances (which could be huge). Here's how we do it:

*   A **diamond-shaped box** is the standard symbol used to display a relationship type. Inside this diamond, we write the name of the relationship (e.g., 'WORKS_ON').
*   This diamond is then **connected to the participating entity types** (which are shown as rectangles) **via straight lines**.

An important stylistic note: the relationship type in an ER diagram is **not shown with an arrow** indicating direction in the same way a data flow diagram might. The relationship name (e.g., 'MANAGES') should ideally be readable from left to right and top to bottom for clarity, though its meaning is defined by its connections and constraints. The semantics come from the overall structure, not from an arrow on the diamond itself."

---

**(Slide 30: Refining the COMPANY database schema by introducing relationships)**

"Now we come to a critical step: **refining our COMPANY database schema by explicitly introducing relationships**. We're moving from that initial design, where some connections were just attributes, to a more formal ER model.

By carefully **examining the requirements** we discussed earlier, we can identify six key relationship types for the COMPANY database:

1.  **WORKS_FOR**: This relationship exists between an EMPLOYEE and a DEPARTMENT. (An employee works for a department).
2.  **MANAGES**: This also exists between an EMPLOYEE and a DEPARTMENT. (An employee manages a department). Note that two distinct relationships can exist between the same pair of entity types if they have different meanings.
3.  **CONTROLS**: This connects a DEPARTMENT to a PROJECT. (A department controls a project).
4.  **WORKS_ON**: This is between an EMPLOYEE and a PROJECT. (An employee works on a project).
5.  **SUPERVISION**: This is a *recursive* relationship on the EMPLOYEE entity type. It involves an EMPLOYEE (as a subordinate) being supervised by another EMPLOYEE (as a supervisor).
6.  **DEPENDENTS_OF**: This links an EMPLOYEE to a DEPENDENT. (A dependent belongs to an employee). This is likely an identifying relationship for the weak entity DEPENDENT.

A key observation here is that **all of these identified relationship types are *binary* relationships**, meaning they each involve exactly two participating entity types (even in the recursive case, EMPLOYEE participates twice in different roles).

The next slide will show us how these relationships integrate into our ER diagram."

---

**(Slide 31: ER DIAGRAM – Relationship Types are: WORKS_FOR, MANAGES, WORKS_ON, CONTROLS, SUPERVISION, DEPENDENTS_OF)**

"And here it is! Figure 3.2 presents a more refined **ER schema diagram for our COMPANY database**. This diagram now explicitly incorporates the six relationship types we just identified. Let's take a closer look.

*   You can see the entity types: **EMPLOYEE**, **DEPARTMENT**, **PROJECT**, and the weak entity **DEPENDENT** (shown with a double rectangle, though not explicitly stated on this slide, it's implied by its nature and identifying relationship). Each has its attributes, with key attributes likely intended to be underlined (though not all are clearly underlined in this rendition).

*   Now, focus on the **diamonds**, which represent the relationship types:
    *   **WORKS_FOR** connects EMPLOYEE and DEPARTMENT. Notice the 'N' near EMPLOYEE and '1' near DEPARTMENT, indicating an N:1 cardinality.
    *   **MANAGES** also connects EMPLOYEE and DEPARTMENT, this one being 1:1. It has an attribute 'Start_date' connected to it, describing when the management role began.
    *   **CONTROLS** links DEPARTMENT (1) to PROJECT (N).
    *   **WORKS_ON** is between EMPLOYEE (M) and PROJECT (N), an M:N relationship. It has an attribute 'Hours' attached.
    *   **SUPERVISION** is a recursive relationship on EMPLOYEE. You see lines coming from EMPLOYEE, looping through the SUPERVISION diamond, and back to EMPLOYEE, with '1' and 'N' indicating the roles of supervisor and supervisee.
    *   **DEPENDENTS_OF** connects EMPLOYEE (1) to DEPENDENT (N). This is the identifying relationship for DEPENDENT.

The diagram also shows an interesting attribute, 'Number_of_employees', connected to DEPARTMENT with a dashed oval, suggesting it might be a *derived* attribute (calculable from the WORKS_FOR relationships).

This diagram gives us a much richer and more accurate conceptual model of the COMPANY database than our initial list of entities and attributes. The diagrammatic notation, as the caption says, is being introduced gradually."

---

**(Slide 32: Discussion on Relationship Types)**

"Let's reflect on the process of refining our design and the nature of these relationship types.

In our **refined design**, you'll notice that several attributes we initially listed in the *entity types* have now been transformed or **refined into relationships**. This is a common and important step.
For example:
*   The 'Manager' attribute we initially thought of for DEPARTMENT has become the **MANAGES** relationship between EMPLOYEE and DEPARTMENT.
*   The 'Works_on' composite attribute in EMPLOYEE has evolved into the **WORKS_ON** relationship between EMPLOYEE and PROJECT.
*   Similarly, the 'Department' attribute in EMPLOYEE is now represented by the **WORKS_FOR** relationship.
And so on for other similar attributes. This makes the model more expressive.

A key point to grasp is that, in general, **more than one relationship type can exist between the same pair of participating entity types**. We saw this clearly with EMPLOYEE and DEPARTMENT.
*   The **MANAGES** relationship and the **WORKS_FOR** relationship are *distinct* relationship types, even though both involve EMPLOYEE and DEPARTMENT.
*   They have **different meanings** (managing is not the same as simply working for) and, consequently, they will have **different relationship instances** in the database. An employee might work for a department but not manage it, or manage a department they also work for. The sets of (employee, department) pairs for MANAGES will be different from those for WORKS_FOR. This ability to model multiple distinct associations is a strength of the ER model."
 
---

Alright, let's resume our discussion, focusing now on how attributes are refined into relationships and the various types of constraints we can place on these relationships.

<div class="page-break"></div>

### Discussion on Relationship Types

Now that we've seen an initial ER diagram for our COMPANY database, let's have a **discussion on these relationship types**.

*   You might have noticed that in the refined design, **some attributes that we initially listed for our entity types have now been refined into relationships**. This is a very common and important step in ER modeling.
    *   For example, the `Manager` attribute of the `DEPARTMENT` entity type, along with `Manager_start_date`, has been transformed into the **MANAGES** relationship between `EMPLOYEE` and `DEPARTMENT`. The `Start_date` is now an attribute *of* this MANAGES relationship.
    *   Similarly, the `Works_on` attribute (which was a composite attribute listing projects and hours) of the `EMPLOYEE` entity type has become the **WORKS_ON** M:N relationship between `EMPLOYEE` and `PROJECT`, with `Hours` as an attribute on this relationship.
    *   And the `Department` attribute of the `EMPLOYEE` entity type has become the **WORKS_FOR** relationship between `EMPLOYEE` and `DEPARTMENT`.
    *   And so on for other attributes that represented connections to other entities.

*   It's also crucial to understand that, **in general, more than one relationship type can exist between the same participating entity types**.
    *   A prime example from our COMPANY schema is between **EMPLOYEE** and **DEPARTMENT**. We have two distinct relationship types:
        *   **MANAGES**: This represents the fact that one employee manages one department.
        *   **WORKS_FOR**: This represents the fact that many employees work for one department.
    *   These are distinct because they have **different meanings** and will result in **different relationship instances** in the database. An employee who manages a department also works for that department, but not every employee who works for a department manages it.

This refinement process, turning attributes into relationships, helps us create a more accurate and expressive model of the miniworld.

<div class="page-break"></div>

### Constraints on Relationships

When we define relationships, it's not enough to just say "these entities are related." We need to specify the *rules* governing these relationships. These rules are called **constraints on relationships**.

There are two main types of constraints on relationship types that we'll discuss:

*   First, **Cardinality Ratio** constraints. These are also sometimes known as ratio constraints.
    *   The cardinality ratio specifies the **maximum participation** of entities in a relationship instance. It tells us the maximum number of relationship instances an entity can participate in.
    *   We typically categorize these as:
        *   **One-to-one (1:1)**: An entity from one set can be related to at most one entity from the other set, and vice-versa. For example, in our `MANAGES` relationship, one `EMPLOYEE` manages at most one `DEPARTMENT`, and one `DEPARTMENT` is managed by at most one `EMPLOYEE`.
        *   **One-to-many (1:N)** or **Many-to-one (N:1)**: An entity from the "one" side can be related to many entities from the "N" side, but an entity from the "N" side can only be related to one entity from the "one" side. Our `WORKS_FOR` relationship is N:1: many `EMPLOYEE`s work for one `DEPARTMENT`.
        *   **Many-to-many (M:N)**: An entity from one set can be related to many entities from the other set, and vice-versa. Our `WORKS_ON` relationship is M:N: an `EMPLOYEE` can work on many `PROJECT`s, and a `PROJECT` can have many `EMPLOYEE`s working on it.

*   Second, the **Existence Dependency Constraint**. This is also often called the **participation constraint**.
    *   This constraint specifies the **minimum participation**. It dictates whether an entity's existence depends on it being related to another entity through a particular relationship.
    *   We have two cases here:
        *   **Zero (optional participation)**: This means an entity is *not* existence-dependent. It *can* exist without participating in the relationship. For example, a new `PROJECT` might exist before any `EMPLOYEE`s are assigned to `WORKS_ON` it.
        *   **One or more (mandatory participation)**: This means an entity *is* existence-dependent. It *must* participate in at least one instance of the relationship. For example, in our model, a `DEPENDENT` entity cannot exist unless it is related to an `EMPLOYEE` through the `DEPENDENTS_OF` relationship. Its existence depends on the employee.

Understanding and correctly specifying these constraints is vital for maintaining data integrity and accurately reflecting the rules of the miniworld.

---

### Many-to-one (N:1) Relationship

Let's revisit the diagram illustrating a **Many-to-one (N:1) Relationship**, specifically our `WORKS_FOR` relationship between `EMPLOYEE` and `DEPARTMENT`.

**Figure 3.9** shows some instances in the `WORKS_FOR` relationship set.

Observe the ovals.
*   The `EMPLOYEE` oval on the left contains entities `e1`, `e2`, `e3`, and so on.
*   The `DEPARTMENT` oval on the right contains entities `d1`, `d2`, `d3`, etc.
*   The `WORKS_FOR` oval in the middle represents the relationship instances, `r1`, `r2`, `r3`, etc.

Notice how:
*   `r1` links `e1` to `d1`.
*   `r2` links `e2` also to `d1`.
*   `r3` links `e3` to `d2`.

This clearly depicts the N:1 nature. Multiple employees (e.g., `e1` and `e2`) can work for the *same* department (`d1`). However, if you look from an employee's perspective, each employee (like `e1`, `e2`, or `e3`) is linked to *only one* department. An employee cannot work for multiple departments simultaneously in *this specific* relationship type.

This N:1 cardinality defines the maximum participation: many employees, one department.

---

### Many-to-many (M:N) Relationship

Now, let's look at an example of a **Many-to-many (M:N) Relationship**, using our `WORKS_ON` relationship between `EMPLOYEE` and `PROJECT`.

**Figure 3.13** illustrates an M:N relationship, `WORKS_ON`.

Again, we have:
*   The `EMPLOYEE` oval on the left (`e1`, `e2`, `e3`, `e4`, ...).
*   The `PROJECT` oval on the right (`p1`, `p2`, `p3`, `p4`, ...).
*   The `WORKS_ON` oval in the middle showing relationship instances (`r1`, `r2`, `r3`, ...).

Observe the connections:
*   `r1` links `e1` to `p1`.
*   `r2` links `e2` to `p2`.
*   Critically, `r3` links `e1` (who is already working on `p1`) to `p2` as well. So, employee `e1` works on *multiple* projects (`p1` and `p2`).
*   And if we look at project `p3`, relationship instance `r4` links `e3` to `p3`, and `r5` links `e4` to `p3`. So, project `p3` has *multiple* employees (`e3` and `e4`) working on it.

This perfectly illustrates the M:N cardinality. An employee can participate in many `WORKS_ON` instances (i.e., work on many projects), and a project can participate in many `WORKS_ON` instances (i.e., have many employees working on it).

<div class="page-break"></div>

### Recursive Relationship Type

Now, let's discuss a special kind of relationship called a **Recursive Relationship Type**.

*   This occurs when a relationship type exists **between the same participating entity type**, but the entities participate in **distinct roles**.
*   It's also commonly called a **self-referencing relationship type** because the entity type refers back to itself.

*   A classic example, and one we have in our COMPANY schema, is the **SUPERVISION** relationship.
*   In this relationship, the **EMPLOYEE** entity type participates twice, but in two distinct roles:
    *   One role is that of the **supervisor** (or boss).
    *   The other role is that of the **supervisee** (or subordinate).

*   So, each individual relationship instance within the `SUPERVISION` set relates **two distinct EMPLOYEE entities**:
    *   One employee is playing the *supervisor role*.
    *   The other employee is playing the *supervisee role*.

This allows us to model hierarchical structures, like reporting lines within a company, using a single entity type.

---

### Displaying a recursive relationship

So, how do we **display a recursive relationship** clearly, especially in our diagrams?

*   As we've established, in a recursive relationship type, **both participations are from the same entity type**, but they are in **different roles**.

*   For example, consider our `SUPERVISION` relationships. These are between an `EMPLOYEE` (in the role of supervisor or boss) and *another* `EMPLOYEE` (in the role of subordinate or worker).

*   In the figure that we'll see on the next slide, which illustrates instances of such a relationship, the first role participation (e.g., supervisor) might be labeled with a '1' and the second role participation (e.g., supervisee) might be labeled with a '2', purely for distinguishing them in that instance diagram.

*   Crucially, when we draw an **ER diagram**, we **need to display these role names** next to the lines connecting the entity type to the relationship diamond. This is essential to distinguish the participations and make the meaning of the recursive relationship clear. Without role names, it would be ambiguous how an entity instance participates.

---

### A Recursive Relationship Supervision

Let's look at **Figure 3.11**, which visualizes instances of **A Recursive Relationship: Supervision**.

This figure shows a recursive relationship `SUPERVISION` between the `EMPLOYEE` entity type.
*   On the left, we have the set of `EMPLOYEE` entities: `e1`, `e2`, `e3`, `e4`, `e5`, `e6`, `e7`, and so on.
*   The `SUPERVISION` oval in the middle represents the instances of this relationship: `r1`, `r2`, `r3`, etc.

The key here is understanding the roles. The caption indicates that `EMPLOYEE` participates in the *supervisor role* (labeled as '1' on the lines originating from the left side of an employee to the relationship instance) and the *subordinate role* (labeled as '2' on the lines originating from the right side of an employee to the relationship instance).

Let's trace a few:
*   `e1` in role '1' (supervisor) is related via `r1` to `e2` in role '2' (subordinate). So, `e1` supervises `e2`.
*   `e1` *also* in role '1' (supervisor) is related via `r2` to `e3` in role '2' (subordinate). So, `e1` also supervises `e3`.
*   Now, consider `e2`. `e2` in role '1' (supervisor) is related via `r3` to `e4` in role '2' (subordinate). So, `e2` (who is supervised by `e1`) in turn supervises `e4`.
*   And `e5` is supervised by `e4` (via `r4`), `e6` is supervised by `e4` (via `r5`), and `e7` is supervised by `e4` (via `r6`).

This clearly illustrates a hierarchical reporting structure where an employee can be a supervisor to some and a supervisee to another. The role names are critical to understanding these distinct participations.

---

### Recursive Relationship Type is: SUPERVISION (participation role names are shown)

Here we see our familiar **COMPANY ER schema diagram (Figure 3.2)** again. The specific focus of this slide title is to highlight the **Recursive Relationship Type: SUPERVISION**, and importantly, to emphasize that the **participation role names are shown**.

If you locate the `EMPLOYEE` entity rectangle, you'll see the `SUPERVISION` diamond connected to it. Notice the lines:
*   One line goes from `EMPLOYEE` to the `SUPERVISION` diamond, and near this line, on the `EMPLOYEE` side, is the role name **Supervisor**. This represents the "1" side of the supervision (an employee in the supervisor role).
*   Another line goes from `EMPLOYEE` back to the `SUPERVISION` diamond, and near this line, on the `EMPLOYEE` side, is the role name **Supervisee**. This represents the "N" side (an employee in the supervisee role).

The cardinalities are also indicated: 1 for the Supervisor role participation and N for the Supervisee role participation, meaning one supervisor can supervise many supervisees, and a supervisee is supervised by one supervisor (in this particular 1:N setup of supervision).

Showing these role names, "Supervisor" and "Supervisee," is absolutely essential for anyone reading this ER diagram to understand the nature of the `SUPERVISION` relationship. Without them, it would just be a diamond connected to `EMPLOYEE` twice, with no clear meaning of *how* an employee participates.

<div class="page-break"></div>

### Weak Entity Types

Now, let's turn our attention to a special category of entities known as **Weak Entity Types**.

*   A weak entity type is an entity that **does not have a key attribute of its own** that can uniquely identify its instances. Furthermore, its identification is **dependent on another entity type**, often called the owner or identifying entity type.

*   Because it cannot stand alone for identification, a weak entity **must participate in an identifying relationship type** with an owner or identifying entity type. This relationship is crucial for its existence and identification. The weak entity type will have total participation in this identifying relationship.

*   So, how are instances of a weak entity type identified? They are identified by the **combination** of two things:
    *   A **partial key** of the weak entity type. A partial key is an attribute (or set of attributes) that can uniquely identify weak entities *that are related to the same owner entity*. It's sometimes called a discriminator.
    *   And, **the particular entity they are related to in the identifying relationship type** – essentially, the key of the owner entity.

*   Let's consider the **Example** from our COMPANY database: the `DEPENDENT` entity.
    *   A `DEPENDENT` entity is identified by the dependent's **first name** (which we'll consider its partial key) *and* the specific **EMPLOYEE** with whom that dependent is related. A dependent's name alone (e.g., "John") is not unique across all dependents in the company, but it is unique for a specific employee.
    *   So, the `Name` of the `DEPENDENT` is the **partial key**.
    *   `DEPENDENT` is a **weak entity type**.
    *   `EMPLOYEE` is its **identifying entity type** (or owner entity type) via the **identifying relationship type** `DEPENDENT_OF`.

In ER diagrams, weak entity types are typically shown as a double rectangle, and their identifying relationship is shown as a double diamond. Their partial key is usually underlined with a dashed line.

---

### Attributes of Relationship types

We've talked about attributes of entities, but can relationships themselves have attributes? Yes, they can. Let's discuss **Attributes of Relationship types**.

*   A relationship type **can indeed have attributes**. These attributes describe a property of the association between the participating entities, rather than a property of an individual entity.

*   For example, consider the `WORKS_ON` relationship type between `EMPLOYEE` and `PROJECT` in our COMPANY database. We might want to store the `HoursPerWeek` that a particular employee works on a particular project.
    *   This `HoursPerWeek` is an attribute of the `WORKS_ON` relationship.
    *   Its value for each relationship instance (i.e., for each specific pairing of an employee and a project they work on) describes the number of hours per week that *that specific employee* works on *that specific project*.

*   It's important to see that a value of `HoursPerWeek` **depends on a particular (employee, project) combination**. It doesn't make sense to store `HoursPerWeek` with just the `EMPLOYEE` (because they might work different hours on different projects) or just with the `PROJECT` (because different employees might work different hours on the same project). It truly describes the *interaction*.

*   You'll find that **most relationship attributes are used with M:N (many-to-many) relationships**. This is because in M:N relationships, there's no single entity on one side to "hold" the attribute naturally.

*   What about 1:N relationships? If a 1:N relationship has attributes, they **can often be transferred to the entity type on the N-side of the relationship**. For example, if `MANAGES` (1:1 between EMPLOYEE and DEPARTMENT) had an attribute, say `ManagementBonus`, it could arguably be placed on the `EMPLOYEE` side if an employee manages at most one department, or if the relationship was 1:N with Employee being the '1' side. However, `Start_date` for `MANAGES` clearly describes when *that specific management relationship* began, so it's best kept on the relationship.

In ER diagrams, an attribute of a relationship is shown as an oval connected to the diamond representing the relationship type.

---

### Example Attribute of a Relationship Type: Hours of WORKS_ON

Let's look at our COMPANY ER diagram (Figure 3.2) again, this time to pinpoint an **Example Attribute of a Relationship Type: the `Hours` attribute of the `WORKS_ON` relationship**.

If you locate the `EMPLOYEE` entity and the `PROJECT` entity, you'll see the `WORKS_ON` diamond connecting them, indicating a many-to-many relationship.

Now, look closely at the `WORKS_ON` diamond. Connected directly to this diamond is an oval labeled **Hours**.
*   This `Hours` attribute represents the number of hours per week an employee works on a specific project.
*   It is an attribute *of the relationship instance* itself. For each pairing of an `EMPLOYEE` and a `PROJECT` through the `WORKS_ON` relationship, there will be a specific value for `Hours`.

This is a perfect illustration of why relationship attributes are necessary. The number of hours is not solely a property of the employee (they work on multiple projects) nor solely a property of the project (multiple employees work on it). It is a property of their specific work assignment – their relationship.

This completes our initial overview of entities, attributes, and the various types and characteristics they can possess. Next, we'll delve deeper into how we formally specify constraints on these relationships.

---

Okay, let's continue our journey through ER modeling, focusing now on how we notate constraints and explore alternative ways to represent our database schemas.

<div class="page-break"></div>

### Notation for Constraints on Relationships

We've discussed the concepts of cardinality ratio and participation constraints. Now, let's look at the **Notation for Constraints on Relationships** as typically depicted in ER diagrams.

*   For the **Cardinality ratio** of a binary relationship (which tells us the maximum participation – 1:1, 1:N, N:1, or M:N):
    *   This is generally **shown by placing appropriate numbers (1, N, M) on the relationship edges**, close to the entity types participating in the relationship. For example, for a 1:N relationship between E1 and E2, you'd see a '1' near E1 and an 'N' near E2 on the lines connecting them to the relationship diamond.

*   For the **Participation constraint** (which tells us the minimum participation – total or partial):
    *   **Total participation** (meaning an entity *must* participate, also called existence dependency) is shown by a **double line** connecting the entity type to the relationship diamond.
    *   **Partial participation** (meaning an entity *may or may not* participate) is shown by a **single line**.

*   A key **NOTE**: These notations – the numbers for cardinality ratio and single/double lines for participation – are relatively straightforward and **easy to specify for Binary Relationship Types**. They give a quick visual cue about the nature of the relationship. For higher-degree relationships, specifying these constraints can become more complex.

We'll see an alternative notation, (min,max), next, which combines both cardinality and participation into a pair of numbers.

---

### Alternative (min, max) notation for relationship structural constraints:

Beyond the separate cardinality ratios and participation lines, there's a very useful and common **Alternative (min, max) notation for specifying relationship structural constraints**. This notation is quite expressive as it combines both minimum and maximum participation in one go.

*   This (min, max) pair is **specified on each participation of an entity type E in a relationship type R**. You'll see it on the line connecting E to R, typically close to E.

*   What does it mean? It **specifies that each entity instance `e` in entity type `E` participates in at least `min` and at most `max` relationship instances in `R`**.
    *   `min` dictates the minimum participation (0 for optional, 1 or more for mandatory).
    *   `max` dictates the maximum participation (1 for one, N or \* for many).

*   There are some ground rules:
    *   The **default**, if no constraint is specified (though this is rare in a complete ERD), can be considered `min=0` and `max=n` (where 'n' or sometimes '*' signifies no upper limit, or many).
    *   Logically, we **must have `min ≤ max`**.
    *   Also, `min` must be greater than or equal to 0 (`min≥0`), and `max` must be greater than or equal to 1 (`max ≥1`) if it's not 'n' or '\*'.

*   How do we determine these (min,max) values? They are **derived from the knowledge of the mini-world constraints** – the business rules of the application we are modeling.

*   Let's look at some **Examples** from our COMPANY database:
    *   Consider the rule: "A department has exactly one manager, and an employee can manage at most one department."
        *   For the participation of `EMPLOYEE` in the `MANAGES` relationship: an employee can manage zero departments (if they are not a manager) or at most one department. So, we would **specify (0,1)** for `EMPLOYEE` in `MANAGES`.
        *   For the participation of `DEPARTMENT` in the `MANAGES` relationship: a department must have exactly one manager. So, we would **specify (1,1)** for `DEPARTMENT` in `MANAGES`.

    *   Consider another rule: "An employee can work for exactly one department, but a department can have any number of employees."
        *   For the participation of `EMPLOYEE` in the `WORKS_FOR` relationship: an employee must work for exactly one department. So, we **specify (1,1)** for `EMPLOYEE` in `WORKS_FOR`.
        *   For the participation of `DEPARTMENT` in the `WORKS_FOR` relationship: a department can have zero employees (e.g., a new department) up to many employees (no specific upper limit, so 'n'). So, we **specify (0,n)** (or sometimes (1,n) if a department must have at least one employee, the rules would clarify this - the slide uses (0,n) implying it can be empty). Let's assume the slide meant (0,n) if it could be empty or (1,n) if it must have at least one. The slide example shows (0,n) for department in WORKS_FOR in one context, and (1,N) later, indicating that it can have 'any number' usually means 0 to many, or 1 to many if the rule is strict. Let's stick to the general idea for now: the (min,max) captures this precisely.

This (min,max) notation is very powerful because it explicitly states both the minimum and maximum participation constraints for each entity type in a relationship.

---

### The (min, max) notation for relationship constraints

Let's visualize **the (min, max) notation for relationship constraints** with a couple of diagrams showing how these pairs are placed.

The slide shows two examples:

1.  **EMPLOYEE --(0, 1)-- MANAGES --(1, 1)-- DEPARTMENT**
    *   The **(0, 1)** is placed on the line connecting `EMPLOYEE` to the `MANAGES` diamond, near `EMPLOYEE`. This means an `EMPLOYEE` entity participates in the `MANAGES` relationship a minimum of 0 times (optional participation – not all employees are managers) and a maximum of 1 time (an employee can manage at most one department).
    *   The **(1, 1)** is placed on the line connecting `DEPARTMENT` to the `MANAGES` diamond, near `DEPARTMENT`. This means a `DEPARTMENT` entity participates in the `MANAGES` relationship a minimum of 1 time (mandatory participation – a department must have a manager) and a maximum of 1 time (a department has exactly one manager).

2.  **EMPLOYEE --(1, 1)-- WORKS FOR --(1, N)-- DEPARTMENT**
    *   The **(1, 1)** near `EMPLOYEE` indicates that an `EMPLOYEE` must work for exactly one `DEPARTMENT` (min=1, max=1).
    *   The **(1, N)** near `DEPARTMENT` indicates that a `DEPARTMENT` must have at least one `EMPLOYEE` (min=1) and can have many `EMPLOYEE`s (max=N, where N signifies many).

The key instruction at the bottom is crucial for interpreting these diagrams: "**Read the min,max numbers next to the entity type and looking *away from* the entity type.**"
What this means is: the (min,max) pair written on the edge near an entity type E specifies the constraint on *that entity type E's participation* in the connected relationship.

So, for `EMPLOYEE --(0,1)-- MANAGES`, the (0,1) describes how `EMPLOYEE` participates in `MANAGES`. For `MANAGES --(1,1)-- DEPARTMENT`, the (1,1) describes how `DEPARTMENT` participates in `MANAGES`.

This notation is very precise and widely used.

---

### COMPANY ER Schema Diagram using (min, max) notation

Now, let's look at our complete **COMPANY ER Schema Diagram using this (min, max) notation**. This is **Figure 3.15**. It also includes role names, which are important for recursive relationships and sometimes for clarity in other relationships.

This diagram is rich with information. Let's highlight some of the key (min,max) constraints specified, which codify the business rules we've been discussing:

*   **MANAGES** relationship (between `EMPLOYEE` and `DEPARTMENT`):
    *   `EMPLOYEE` (Manager role) participates with **(0,1)**. (An employee can be a manager of 0 or 1 department).
    *   `DEPARTMENT` (Managed role) participates with **(1,1)**. (A department must be managed by exactly 1 employee).
    *   The attribute `Start_date` is on this relationship.

*   **WORKS_FOR** relationship (between `EMPLOYEE` and `DEPARTMENT`):
    *   `EMPLOYEE` (Employee role) participates with **(1,1)**. (An employee must work for exactly one department).
    *   `DEPARTMENT` (Department role) participates with **(4,N)**. (A department must have at least 4 employees and can have many. This is a more specific rule than just 'many').

*   **CONTROLS** relationship (between `DEPARTMENT` and `PROJECT`):
    *   `DEPARTMENT` (Controlling Department role) participates with **(0,N)**. (A department can control 0 to many projects).
    *   `PROJECT` (Controlled role) participates with **(1,1)**. (A project must be controlled by exactly one department).

*   **WORKS_ON** relationship (between `EMPLOYEE` and `PROJECT`):
    *   `EMPLOYEE` (Worker role) participates with **(0,N)**. (An employee can work on 0 to many projects).
    *   `PROJECT` (Project role) participates with **(1,N)**. (A project must have at least 1 employee and can have many).
    *   The attribute `Hours` is on this relationship.

*   **SUPERVISION** relationship (Recursive on `EMPLOYEE`):
    *   `EMPLOYEE` (Supervisor role) participates with **(0,N)**. (An employee can supervise 0 to many other employees).
    *   `EMPLOYEE` (Supervisee role) participates with **(0,1)**. (An employee is supervised by 0 or 1 supervisor. 0 implies a top-level manager might not have a supervisor within this context).

*   **DEPENDENTS_OF** relationship (Identifying relationship between `EMPLOYEE` and weak entity `DEPENDENT`):
    *   `EMPLOYEE` (Employee role) participates with **(0,N)**. (An employee can have 0 to many dependents).
    *   `DEPENDENT` (Dependent role) participates with **(1,1)**. (A dependent must belong to exactly one employee. This is typical for an identifying relationship from the weak entity's side). `DEPENDENT` is shown as a double rectangle, and `DEPENDENTS_OF` as a double diamond.

The diagram also shows all the attributes for each entity type, with keys underlined (e.g., `Ssn` for `EMPLOYEE`, composite `Name` and `Number` for `DEPARTMENT` and `PROJECT`, and `Name` as partial key for `DEPENDENT`). Multivalued attributes like `Locations` for `DEPARTMENT` are in double ovals. Derived attributes like `Number_of_employees` for `DEPARTMENT` are in dashed ovals.

This diagram, using (min,max) notation and role names, provides a very detailed and unambiguous specification of the conceptual schema for our COMPANY database. It's a lot to take in, but each part conveys a specific rule or piece of information.

<div class="page-break"></div>

### Alternative diagrammatic notation

While the ER diagram notation we've been learning (often associated with Elmasri and Navathe) is very popular and expressive, it's important to be aware that there are **alternative diagrammatic notations** used in the literature and in various database design and modeling tools.

*   Indeed, **ER diagrams**, as we've seen, are one prominent example for displaying database schemas conceptually.

*   However, **many other notations exist**. You might encounter variations in symbols for entities, attributes, relationships, and especially for constraints like cardinality and participation. Different textbooks, different CASE tools, and different methodologies might have their own slight variations or entirely different graphical languages.

*   For those interested, **Appendix A** in your textbook illustrates some of the alternative notations that have been used over the years. It's a good reference if you come across a diagram that looks a bit different from what we're primarily using.

*   One very significant alternative, which has gained widespread adoption, particularly in software engineering and object-oriented modeling, is **UML class diagrams**. UML (Unified Modeling Language) provides a set of standard diagrams for specifying, visualizing, constructing, and documenting the artifacts of software systems. Its class diagrams can be used effectively to represent ER concepts, and they are used in several commercial design tools for database modeling as well. We'll take a closer look at UML class diagrams shortly.

The key is to understand the underlying concepts. Once you grasp entities, attributes, relationships, and constraints, you can usually adapt to different notations, though it's always good practice to have a legend if the notation is unfamiliar.

---

### Summary of notation for ER diagrams

Before we move to UML, let's quickly revisit the **Summary of notation for ER diagrams** that we are primarily using in this course. This is **Figure 3.14** again.

*(The professor would briefly gesture to the symbols on the slide, reiterating their meaning if needed, similar to the explanation for slide 3-18/3-48 which shows this exact summary table.)*

Just to recap:
*   **Entity**: A plain rectangle.
*   **Weak Entity**: A double rectangle.
*   **Relationship**: A diamond.
*   **Identifying Relationship** (for weak entities): A double diamond.
*   **Attribute**: An oval.
*   **Key Attribute**: An oval with underlined text.
*   **Multivalued Attribute**: A double oval.
*   **Composite Attribute**: An oval connected to other ovals representing its components.
*   **Derived Attribute**: A dashed oval.

And for constraints:
*   **Total Participation** of an entity (say, E₂) in a relationship R: Indicated by a double line connecting E₂ to R.
*   **Cardinality Ratio** (e.g., 1:N for E₁:E₂ in R): Shown with numbers like '1' and 'N' on the lines connecting E₁ and E₂ to R.
*   **Structural Constraint (min, max)** on the participation of an entity E in R: Shown as `(min, max)` on the line connecting E to R.

This set of symbols forms the visual language we're using to build our conceptual schemas.

<div class="page-break"></div>

### UML class diagrams

Now, let's turn our attention to **UML class diagrams**, a significant alternative notation for conceptual modeling that you are very likely to encounter. UML stands for Unified Modeling Language.

*   In UML class diagrams, we **represent classes** (which are conceptually similar to our entity types) as **large rounded boxes**. These boxes typically have **three sections**:
    *   The **Top section** includes the **entity type (class) name**.
    *   The **Second section** lists the **attributes** of the class.
    *   The **Third section** can include **class operations** (which are like methods or functions that can be performed on objects of that class). This concept of operations is not present in the basic ER model we've discussed, which focuses purely on data structure.

*   **Relationships** in UML are called **associations**, and they are represented as **lines connecting the classes**.

*   It's important to note that **other UML terminology also differs from ER terminology**. For instance, relationship instances are called "links." We'll see more of these differences.

*   UML class diagrams are extensively **used in database design**, especially when the database is being designed in conjunction with object-oriented software. They are, of course, a cornerstone of **object-oriented software design** itself.

*   UML is a very comprehensive language and **has many other types of diagrams** for various aspects of software design, such as use case diagrams, sequence diagrams, activity diagrams, etc. Our focus here is specifically on its class diagrams and how they map to ER concepts.

---

### UML class diagram for COMPANY database schema

Let's now look at **Figure 3.16**, which presents the **UML class diagram for our COMPANY database schema**. This will allow us to see how the same concepts we modeled with ER diagrams are represented in UML.

On the left side of the slide, you see the UML class diagram.
*   **Classes (Entities):**
    *   You'll see boxes for `EMPLOYEE`, `DEPARTMENT`, `PROJECT`, `LOCATION`, and `DEPENDENT`.
    *   Inside `EMPLOYEE`, for example, the top section has "EMPLOYEE". The second section lists attributes like `Name: Name_dom`, `Ssn`, `Bdate: Date`, etc. `Name_dom` here would represent a structured type for the composite name. Notice the data types specified after a colon.
    *   `DEPARTMENT` has attributes `Name`, `Number`, and in its third section, operations like `add_employee()`, `number_of_employees()`, `change_manager()`.

*   **Associations (Relationships) & Multiplicities:**
    *   Lines connect these classes. For instance, a line connects `EMPLOYEE` and `DEPARTMENT` labeled `WORKS_FOR`.
    *   **Multiplicities** are shown at the ends of the association lines, near the participating classes. For `EMPLOYEE` ---`WORKS_FOR`--- `DEPARTMENT`, you might see `1..1` near `DEPARTMENT` (an employee works for one department) and `4..*` near `EMPLOYEE` (a department has 4 to many employees). *Note: In UML, the multiplicity at one end describes the number of instances of that class that can be associated with *one* instance of the class at the *other* end. So, if EMPLOYEE connects to WORKS_FOR which connects to DEPARTMENT, the `1..1` is next to DEPARTMENT, meaning one EMPLOYEE instance is linked to exactly one DEPARTMENT instance via WORKS_FOR. The `4..*` would be next to EMPLOYEE, meaning one DEPARTMENT instance is linked to 4 or more EMPLOYEE instances.* The diagram shows `4.*` next to `EMPLOYEE` and `1..1` next to `DEPARTMENT` for the `WORKS_FOR` association.
    *   The `MANAGES` association between `EMPLOYEE` and `DEPARTMENT` has `0..1` near `DEPARTMENT` and `1..1` near `EMPLOYEE` (meaning an employee manages 0 or 1 department; a department is managed by 1 employee). An association class `Start_date` is connected to this `MANAGES` line, representing an attribute of the relationship.
    *   `DEPENDENT` is shown with a `Dependent_name` qualifier on the association line from `EMPLOYEE`, indicating how weak entities are often handled.
    *   An **aggregation** (a form of "has-a" relationship) is shown between `DEPARTMENT` and `LOCATION` with a diamond on the `DEPARTMENT` side, signifying `DEPARTMENT` is the "whole" and `LOCATION` is the "part".

*   **Multiplicity Notation examples** are given on the slide, like `1..1`, `0..*`, `0..1`.

*   **Aggregation Notation** (the open diamond) is also highlighted.

On the right side of the slide, for comparison, is our earlier ER diagram (Figure 3.15) using the (min,max) notation. This allows you to directly compare how similar concepts are visualized.

UML class diagrams are very rich and have their own precise semantics. We're just scratching the surface here to see the parallels with ER modeling.

---

### UML class diagram Notation: Attributes

Let's delve a bit deeper into some specific **UML class diagram Notation**, starting with **Attributes**.

*   As we saw in the example, **attributes can have their domains or data types specified after a colon**.
    *   For example, `Bdate: Date` indicates that the `Bdate` attribute is of type Date.
    *   A domain (a set of allowed values) can also be specified, like `Sex: {M, F}`, meaning the `Sex` attribute can only take values 'M' or 'F'.

*   How are **Composite attributes** handled?
    *   They are typically modeled as **structured domains** or by creating a separate class for the composite structure if it's complex.
    *   For instance, `Name` with components `Fname`, `Minit`, `Lname` might be represented by defining a `Name_dom` (Name domain) type that encapsulates these components, and then an attribute `name: Name_dom`.

*   What about **Multivalued attributes**, like `Locations` for a department?
    *   These are often modeled as **separate classes**. So, instead of a multi-valued attribute `Locations` on `DEPARTMENT`, we would have a `LOCATION` class, and an association between `DEPARTMENT` and `LOCATION` with a multiplicity indicating "many" on the `LOCATION` side (e.g., `1..*` or `0..*`). This is exactly what was done in the UML example for `COMPANY` where `LOCATION` was a separate class.

This approach of using separate classes for multivalued attributes and complex composite structures aligns well with object-oriented principles where everything tends to be an object of some class.

---

### UML class diagram Notation: Associations

Next, let's look at the UML notation for **Associations**, which are the UML equivalent of relationship types in ER modeling.

*   As mentioned, in UML, relationship types are called **associations**, and individual relationship instances are called **links**.

*   A **binary association** (which corresponds to a binary relationship in ER) is represented simply as a **line connecting two classes**. The name of the association can be written near the line.

*   What about attributes of relationships? In UML, these are called **link attributes** (or association attributes).
    *   They are typically placed in a **box** (representing an "association class") that is **connected to the association line by a dashed line**.
    *   We saw this in Figure 3.16: `Start_date` for the `MANAGES` association and `Hours` for the `WORKS_ON` association were represented this way.

*   UML also distinguishes between **Unidirectional vs. Bidirectional Associations**:
    *   **Unidirectional**: If the association is meant to be traversed or accessed in only one direction, an **arrow** is placed on the association line indicating that direction. For example, if ClassA is associated with ClassB, but we only ever navigate from A to B and never from B to A, an arrow would point from A to B.
    *   **Bidirectional**: This is the **default**. If no arrow is displayed, the association is assumed to be navigable in both directions.
    *   **Example**: The `MANAGES` association between `EMPLOYEE` and `DEPARTMENT` could be modeled as unidirectional (e.g., with an arrow pointing from `DEPARTMENT` to `EMPLOYEE`) if the application always accesses the manager employee *from* the `DEPARTMENT` object and never needs to find the department managed *by* a specific employee directly through that association.

These details allow for a more nuanced specification of how classes interact, which can be important when translating the model into an object-oriented programming language.

---

Alright, let's continue with the UML class diagram notation.

### UML class diagram Notation: Multiplicities

We've touched on **Multiplicities** in UML, but let's clarify them further. They are the UML way of expressing cardinality and participation constraints.

*   As stated, **multiplicities in UML are conceptually similar to the (min, max) notation** we learned for ER diagrams. They specify the number of instances of one class that can be related to an instance of another class via an association.

*   They are specified in the form **`min..max`** (read as "min to max").
    *   The asterisk `*` is used to indicate **no maximum limit**, essentially meaning "many."
    *   **Example**: `1..*` means "at least one, and possibly many" (one to many). `0..1` means "zero or one." `*` by itself usually means `0..*` (zero to many). `5..5` would mean exactly five.

*   A very important point of distinction from some ER notations is how they are placed: **Multiplicities are placed at the *opposite ends* of the association line compared to how (min,max) constraints are sometimes read in ER diagrams.**
    *   Specifically, the multiplicity placed at the end of an association line, *next to a class*, defines the number of instances of *that class* that can participate in the association with *one instance* of the class at the *other end*.
    *   For example, if we have `CLASS_A ---association--- CLASS_B` and the multiplicity `1..*` is near `CLASS_B`, and `1..1` is near `CLASS_A`. This means:
        *   One instance of `CLASS_A` is associated with one to many (`1..*`) instances of `CLASS_B`.
        *   One instance of `CLASS_B` is associated with exactly one (`1..1`) instance of `CLASS_A`.
    *   So, you read "across" the association.

This might take a little getting used to if you're very familiar with a different ER notation style, but it's standard in UML.

---

### UML class diagram Notation: Aggregation

UML provides a special type of association called **Aggregation** to represent "whole-part" relationships.

*   **Aggregation represents a whole-part relationship**. This is a type of association where one class (the "whole") is composed of, or contains, other classes (the "parts").
    *   An example often given is a `Department` (whole) and its `Employees` (parts), or in our COMPANY diagram (Figure 3.16), a `DEPARTMENT` (whole) and its `LOCATION`s (parts). The idea is that the parts belong to the whole.

*   How is it represented? It is shown by an **open (unfilled) diamond shape on the side of the "whole"** class, at the end of the association line.
    *   So, in `DEPARTMENT <>--- LOCATION`, the diamond is on the `DEPARTMENT` end, indicating `DEPARTMENT` is the whole and `LOCATION` is the part.

*   It's worth noting that the semantic distinction between a regular association and an aggregation can sometimes be subtle. **Aggregation and association do not inherently have different structural properties or constraints** beyond what multiplicities already define. The choice between using a plain association versus an aggregation is often **somewhat subjective** and depends on whether the modeler wants to explicitly emphasize a whole-part semantic.
    *   Aggregation implies a looser coupling than a stronger form called "Composition" (represented by a filled diamond in UML), where the lifecycle of the part is strictly tied to the whole. We are focusing on aggregation here.

Aggregation helps to convey more meaning about the nature of the relationship between classes.

---

### UML class diagram Notation: Weak Entities in UML

How does UML handle **Weak Entities**? The approach is a bit different from the double rectangles and double diamonds in ER diagrams.

*   **Weak entities in UML are typically modeled using qualified associations** (or sometimes *qualified aggregations*, if a whole-part semantic is also appropriate).

*   What is a qualified association? The **partial key** of the weak entity (which is often called the **discriminator** in this context) is placed in a **small box attached to the class symbol of the *owner* class**, on the association line leading to the weak entity class.

*   **Example**: In our COMPANY schema (Figure 3.16), the `DEPENDENT` class is a weak entity, identified by an `EMPLOYEE`.
    *   Its partial key (discriminator) is `Dependent_name`.
    *   In the UML diagram, you'd see the `EMPLOYEE` class connected to the `DEPENDENT` class. On the `EMPLOYEE` side of this association, there would be a small box attached to the `EMPLOYEE` class rectangle, containing `Dependent_name`. This box is the qualifier.

*   **The qualified association effectively represents both the identifying relationship and the partial key** in a single construct. The qualifier (`Dependent_name`) plus the object identifier of the owner (`EMPLOYEE`) uniquely identifies an instance of the weak entity (`DEPENDENT`).

This is a more object-oriented way of thinking about identification for entities whose identity depends on others.

<div class="page-break"></div>

### Other alternative diagrammatic notations

As we've mentioned, the world of data modeling has seen various graphical languages. This slide, showing **Figure A.1**, gives a glimpse into some **Other alternative diagrammatic notations**.

This figure is a compilation and is quite dense, so I won't go through every single symbol, but I want you to appreciate the variety.

*   **(a) Entity type/class symbols**: You can see different ways to draw an entity – a simple rectangle (like we use), or sometimes a rectangle with rounded corners.
*   **(a) Attribute symbols**: Ovals are common (as we use), but sometimes attributes are just listed inside the entity box, or might have different shapes in other notations.
*   **(a) Relationship symbols**: The diamond is prevalent for relationships, but some notations might just use a line with the relationship name written on it.

*   **(b) Displaying attributes**: This section shows variations:
    *   Our familiar ovals connected to the entity.
    *   Attributes listed directly inside the entity rectangle, often with the primary key underlined or marked (e.g., `Ssn`).
    *   Attributes listed with their data types (e.g., `Name: String`, `Address: Address_Type`).

*   **(c) Displaying cardinality ratios**: This is where you see significant variation.
    *   Numbers like 1, N, M placed on the lines (similar to one of our basic ER notations).
    *   The "crow's foot" notation is very popular, where a single line means 'one' and a three-pronged 'crow's foot' means 'many'. A circle can mean 'zero' (optional) and a bar can mean 'one' (mandatory).
    *   Specific symbols for 1:1, 1:N, M:N relationships.

*   **(d) Various (min, max) notations**: This shows different ways to represent the (min, max) constraints we just discussed.
    *   Our `(0,n)`, `(1,1)` notation.
    *   Notations using symbols like a circle for 0 and a perpendicular bar for 1 on the relationship line to denote min participation, combined with single line or crow's foot for max participation. For example, `o-|` might mean (0,1), `|-||` might mean (1,N) if the double bar is a crow's foot.

*   **(e) Notations for displaying specialization/generalization** (which we'll cover in EER models):
    *   A triangle connecting a superclass to subclasses, sometimes with 'd' for disjoint or 'o' for overlapping.
    *   Other specific symbols like 'Gs' or just hierarchical lines.

The main point here is not to memorize all of these, but to be aware that when you encounter an ER-like diagram in a different book, tool, or paper, you might need to check its specific legend or conventions. The underlying concepts of entities, attributes, relationships, and constraints remain the same.

<div class="page-break"></div>

### Relationships of Higher Degree

So far, most of the relationships we've discussed and seen in our COMPANY example (like `WORKS_FOR`, `MANAGES`, `WORKS_ON`) have been *binary* relationships – they involve two participating entity types. But can relationships involve more than two? Yes, they can. This leads us to **Relationships of Higher Degree**.

*   As a point of terminology:
    *   Relationship types of **degree 2** (involving two entity types) are called **binary**. This is the most common type.
    *   Relationship types of **degree 3** (involving three entity types) are called **ternary**.
    *   And, in general, a relationship type involving `n` entity types is called an **n-ary** relationship.

*   A very important conceptual point: **In general, an n-ary relationship is NOT equivalent to `n` separate binary relationships** among the participating entity types. A single ternary relationship, for instance, can capture a meaning or a constraint that cannot be accurately represented by trying to break it down into three binary relationships. We'll see an example of this shortly.

*   One of the challenges with higher-degree relationships (where `n > 2`) is that **constraints are harder to specify** for them compared to binary relationships. Defining clear cardinality ratios and participation constraints for ternary or n-ary relationships requires more careful thought and often more complex notation.

While less common than binary relationships, n-ary relationships are sometimes necessary to accurately model complex interactions in the miniworld.

---

### Discussion of n-ary relationships (n > 2)

Let's continue our **discussion of n-ary relationships**, specifically for n greater than 2 (like ternary relationships).

*   As I just mentioned, **in general, 3 binary relationships can represent different information than a single ternary relationship**.
    *   We will see this illustrated clearly in **Figure 3.17a and 3.17b** on the next slide. Figure 3.17a will show a single ternary relationship, and 3.17b will show three binary relationships involving the same three entity types. You'll see that they don't necessarily mean the same thing.

*   This doesn't mean you can't have both. **If needed, the binary relationships and an n-ary relationship (involving some or all of the same entity types) can all be included in the schema design**.
    *   This would be appropriate if they genuinely represent different associations or facts in the miniworld. Figure 3.17a and 3.17b will effectively show a scenario where they *do* convey different meanings if considered together.

*   There's also an interesting modeling alternative: **In some cases, a ternary relationship can be represented as a weak entity type**, *if* the data modeling environment or the specific ER notation allows a weak entity type to have **multiple identifying relationships** (and therefore, multiple owner entity types).
    *   We'll see this approach in **Figure 3.17c**. The idea is to create a new entity type (which will be weak) to represent the n-ary relationship, and then link this new entity type to the `n` original participating entity types via identifying binary relationships.

So, modeling n-ary relationships requires careful consideration of the precise semantics you want to capture.

---

### Example of a ternary relationship

Now, let's look at **Figure 3.17**, which provides an excellent **Example of a ternary relationship** and its alternatives. This figure has three parts: (a), (b), and (c).

**(a) The SUPPLY relationship (a ternary relationship)**
*   Here we see three entity types: `SUPPLIER` (with attribute `Sname`), `PART` (with attribute `Part_no`), and `PROJECT` (with attribute `Proj_name`).
*   There is a single diamond labeled `SUPPLY` connected to all three of these entity types. This `SUPPLY` relationship is **ternary**.
*   It also has an attribute, `Quantity`.
*   The meaning here is that a specific `SUPPLIER` supplies a specific `PART` to a specific `PROJECT`, and the `Quantity` is associated with this three-way association. For example, "Supplier S1 supplies 100 units of Part P1 to Project J1." This is a single fact involving all three.

**(b) Three binary relationships not equivalent to SUPPLY**
*   Now, look at part (b). We have the same three entity types: `SUPPLIER`, `PART`, and `PROJECT`.
*   But instead of one ternary relationship, we have three *binary* relationships:
    *   `SUPPLIER` --(M)-- `SUPPLIES` --(N)-- `PROJECT`: This says a supplier supplies projects, and a project is supplied by suppliers. It *doesn't* mention which part.
    *   `PROJECT` --(M)-- `USES` --(N)-- `PART`: This says a project uses parts, and a part is used by projects. It *doesn't* mention the supplier.
    *   `SUPPLIER` --(M)-- `CAN_SUPPLY` --(N)-- `PART`: This says a supplier can supply parts, and a part can be supplied by suppliers. It *doesn't* mention for which project.
*   Clearly, these three binary relationships, even if they all exist, do *not* convey the same specific information as the single ternary `SUPPLY` relationship in (a). The ternary relationship in (a) ties all three together in a single instance (e.g., Supplier S1, Part P2, Project J3, Quantity 50). The binary relationships in (b) only give pairwise associations.

**(c) SUPPLY represented as a weak entity type**
*   Part (c) shows an alternative way to model the ternary relationship concept from (a), by **representing `SUPPLY` as a weak entity type**.
*   We create a new entity type, let's call it `SP` (for Supply instance, though the diagram just shows it as a diamond with SUPPLY inside becoming an entity). Let's assume it's an entity called `SUPPLY_EVENT`.
*   This `SUPPLY_EVENT` entity type would have the attribute `Quantity`.
*   It would then be connected via **identifying binary relationships** to `SUPPLIER`, `PROJECT`, and `PART`.
    *   `SUPPLIER` --(1)-- `SS` --(N)-- `SUPPLY_EVENT`
    *   `PROJECT` --(1)-- `SPJ` --(N)-- `SUPPLY_EVENT`
    *   `PART` --(1)-- (some relationship) --(N)-- `SUPPLY_EVENT`
*   Here, `SUPPLY_EVENT` would be a weak entity whose identity is derived from the combination of a specific `SUPPLIER`, a specific `PROJECT`, and a specific `PART`.
*   This approach essentially "reifies" the relationship into an entity. It's a common technique, especially when the n-ary relationship itself has many attributes or participates in other relationships.

This example beautifully illustrates the distinct nature of n-ary relationships and some common ways to model them.

<div class="page-break"></div>

### Another Example: A UNIVERSITY Database

To further solidify our understanding and see ER modeling in action with a more complex scenario, let's consider **Another Example: A UNIVERSITY Database**.

*   The purpose of this database is **to keep track of the enrollments in classes and student grades**, among other university-related information. So, it's a familiar domain for many of you.

*   What kind of information does it keep track of?
    *   It keeps track of **COLLEGEs** within the university.
    *   **DEPARTMENTs** within each college.
    *   The **COURSEs** offered by these departments.
    *   **SECTIONs** of these courses (as a single course like 'Intro to DB' might have multiple sections at different times or with different instructors).
    *   **INSTRUCTORs** who teach these sections.
    *   And, of course, **STUDENTs** and their enrollment and grades. (Though student is not explicitly listed in this bullet, it's implied by "enrollments in classes and student grades").

*   **These entity types and the relationships among them** are going to be shown on the **next slide in Figure 3.20**. This will be a fairly comprehensive ER diagram using the (min,max) notation.

So, let's prepare to examine another detailed conceptual schema.

---

### UNIVERSITY database conceptual schema

Here we have the **UNIVERSITY database conceptual schema**, as shown in **Figure 3.20**. This is a detailed ER diagram using (min,max) notation.

Let's walk through some of the main components:

*   **Entity Types** (rectangles with attributes listed inside or as ovals):
    *   `COLLEGE` (with attributes like `CName`, `CPhone`, `COffice`).
    *   `DEPARTMENT` (`DCode`, `DName`, `DPhone`, `DOffice`).
    *   `INSTRUCTOR` (`Id`, `IName`, `IPhone`, `Rank`, `IOffice`).
    *   `COURSE` (`CCode`, `CoName`, `CDesc`, `Credits`, `Level`).
    *   `SECTION` (This is a weak entity, identified by `COURSE` via the `SECS` relationship. Its partial key includes `SecNo`, `Sem`, `Year`. It also has attributes like `CRoom`, `Bldg`, `RoomNo`. The diagram shows `SecId` as a key for section, implying it might not be weak in this specific depiction, or `SecId` is formed from course key + partial key. Let's assume `SecId` is its key for now based on the underlining).
    *   `STUDENT` (with attributes like `SId` (key), `SName` (composite: `FName`, `LName`, `MName`), `DOB`, `Addr`, `Phone`, `Major`).

*   **Relationships** (diamonds with (min,max) constraints):
    *   `COLLEGE` --(0,N)-- `ADMINS` --(1,1)-- `DEPARTMENT`: A college administers 0 to N departments; a department is administered by exactly 1 college.
    *   `COLLEGE` --(1,1)-- `DEAN` --(0,1)-- `INSTRUCTOR`: A college has exactly 1 dean; an instructor is a dean of 0 or 1 college. Attribute: `CStartDate`.
    *   `DEPARTMENT` --(1,1)-- `CHAIR` --(0,1)-- `INSTRUCTOR`: A department has exactly 1 chair; an instructor is chair of 0 or 1 department.
    *   `DEPARTMENT` --(0,N)-- `EMPLOYS` --(1,1)-- `INSTRUCTOR`: A department employs 0 to N instructors; an instructor is employed by exactly 1 department.
    *   `DEPARTMENT` --(0,N)-- `HAS` --(0,1)-- `STUDENT`: A department "has" 0 to N students (e.g., students majoring in it); a student belongs to 0 or 1 department as their major.
    *   `DEPARTMENT` --(0,N)-- `OFFERS` --(1,1)-- `COURSE`: A department offers 0 to N courses; a course is offered by exactly 1 department.
    *   `COURSE` --(0,N)-- `SECS` --(1,1)-- `SECTION`: A course has 0 to N sections; a section belongs to exactly 1 course. (If `SECTION` is weak, this would be an identifying relationship).
    *   `STUDENT` --(5,N)-- `TAKES` --(0,N)-- `SECTION`: A student takes between 5 and N sections (an interesting constraint, maybe total credits? Or per semester? The 'N' means many); a section is taken by 0 to N students. Attribute on `TAKES`: `Grade`.
    *   `INSTRUCTOR` --(1,1)-- `TEACHES` --(0,N)-- `SECTION`: An instructor teaches 0 to N sections (0 if on leave, etc.); a section is taught by exactly 1 instructor. (The (1,1) on INSTRUCTOR side and (0,N) on SECTION side implies: an instructor must be assigned to a section, but teaches many? No, (1,1) on SECTION means section has one instructor. (0,N) on INSTRUCTOR means instructor teaches 0 to N sections. This is more logical.) The diagram shows `INSTRUCTOR -- (0,N) -- TEACHES -- (1,1) -- SECTION`. So an instructor teaches 0 to N sections. A section is taught by exactly 1 instructor.

This is another complex schema, but it illustrates how ER diagrams, especially with (min,max) notation, can capture a lot of real-world semantics for a non-trivial application domain like a university. Each entity, attribute, relationship, and constraint has a specific meaning derived from the requirements.

---

### Another example (Car Insurance)

Let's look at yet **another example** to see ER diagrams in a different context. This one appears to be for a **Car Insurance** scenario.

*   **Entities** (Rectangles with ovals for attributes):
    *   `Client` (Attributes: `Lic#` (PK - underlined), `Age`, `Name`).
    *   `Car-Policy` (Attributes: `VIN` (PK - underlined), `Year`).
    *   `Insurance-Agent` (Attributes: `Agent#` (PK - underlined), `Address`, `Tel#`).
    *   `Accidents` (Attributes: `Date`, `Costs`. It's not explicitly stated if `Accidents` has its own key or if it's identified through relationships, perhaps like a weak entity or an associative entity).

*   **Relationships** (Diamonds with cardinalities like 1, n, m):
    *   `Client` --(1)-- `Owns` --(n)-- `Car-Policy`: A client owns one or more (n) car policies. A car policy is owned by one (1) client. (This is a 1:N relationship from Client to Car-Policy).
    *   `Car-Policy` --(n)-- `Insured-by` --(1)-- `Insurance-Agent`: A car policy is insured by one (1) insurance agent. An insurance agent insures one or more (n) car policies. (This is an N:1 relationship from Car-Policy to Insurance-Agent).
        *   Attribute on the `Insured-by` relationship: `Policy#`. This is interesting, as `Car-Policy` already has `VIN`. `Policy#` might be the insurer's specific policy number for that VIN.
    *   `Car-Policy` --(n)-- `Involved` --(m)-- `Accidents`: A car policy can be involved in zero to many (m) accidents. An accident involves one or more (n) car policies (e.g., a multi-car accident). This is an M:N relationship.
    *   `Insurance-Agent` --(1)-- `Keeps-Rec` (Keeps Record) --(n)-- `Accidents`: An insurance agent keeps records for zero to many (n) accidents. An accident record is kept by one (1) insurance agent. (This is a 1:N relationship from Insurance-Agent to Accidents).

This diagram illustrates how different entities in an insurance domain are interconnected, with specific cardinalities defining the business rules.

---

### Another example (Parts, Stores, Shelves, Manufacturer)

Here's **another example**, this time seemingly related to inventory management for **Parts, Stores, Shelves, and a Manufacturer**.

*   **Entities**:
    *   `Parts` (Attributes: `Pid` (PK), `Make`, `Space`, `Cost`, `Price`).
    *   `Stores` (Attributes: `Sid` (PK), `Name`).
    *   `Shelves` (Attributes: `Size`. Note: `Sid` is shown near `Shelves` but `Sid` is the PK of `Stores`. This might imply `Shelves` are identified by `Store Sid` and perhaps a shelf number, making it weak, or there's an error in the diagram placement). Let's assume `Size` is its primary attribute for now. The line between Stores and Shelves suggests a 1:1.
    *   `Manufacturer` (Attributes: `Mid` (PK), `Name`).

*   **Relationships**:
    *   `Parts` --(N)-- (Implicit Relationship, possibly "Stored_In") --(M)-- `Stores`: This appears to be an M:N relationship. A part can be in many stores, and a store can have many parts.
        *   Attribute potentially on this relationship: `Remove_date`.
    *   `Stores` --(1)-- (Implicit Relationship, possibly "Contains" or "Has") --(1)-- `Shelves`: This is shown as a 1:1 relationship. A store has one set of shelves (or one shelf entity as per this model), and a shelf entity belongs to one store. (This is a bit simplistic for real shelves, but it's what the diagram shows).
    *   `Manufacturer` --(N)-- `Builds` --(1)-- `Stores`: A manufacturer builds one or more (N) stores. A store is built by one (1) manufacturer. (N:1 from Manufacturer to Stores).
    *   `Manufacturer` --(1)-- `Designs` --(1)-- `Shelves`: A manufacturer designs one type of shelf (or a specific shelf instance in this model). A shelf (type/instance) is designed by one manufacturer. (1:1 relationship).

This diagram, while a bit less explicit in relationship naming for all connections, still conveys structure. The placement of `Sid` near `Shelves` when it's a PK of `Stores` connected by a 1:1 relationship might imply that `Shelves` could be uniquely identified within the context of a `Store`, or that `Sid` also acts as a foreign key to identify the store a shelf belongs to if `Shelves` had its own independent key. Given the 1:1, it might even suggest `Shelves` is an extension of `Stores` or very tightly coupled.

---

### Another example (Faculty, Course, Teaches)

And one more brief **example**, this one from an academic setting: **Faculty, Course, and a Teaches relationship**.

*   **Entities**:
    *   `Faculty` (Attributes: `fid` (PK - underlined), `phone`, `dept`).
    *   `Course` (Attributes: `cnum` (PK - underlined), `title`, `dept`).

*   **Relationship**:
    *   `Faculty` --(1, 4)-- `Teaches` --(0, 2)-- `Course`:
        *   The `(1, 4)` next to `Faculty` (on the line connecting to `Teaches`) means a `Faculty` member teaches a minimum of 1 course and a maximum of 4 courses.
        *   The `(0, 2)` next to `Course` (on the line connecting to `Teaches`) means a `Course` is taught by a minimum of 0 faculty members (e.g., a new course not yet assigned an instructor) and a maximum of 2 faculty members (e.g., team-taught).
        *   Attributes on the `Teaches` relationship itself: `stu-count` (student count in that specific teaching instance) and `semester`.

This clearly uses the (min,max) notation to define the participation and cardinality constraints for the `Teaches` relationship.

<div class="page-break"></div>

### Chapter Summary

Alright class, that brings us to the end of our detailed exploration of Chapter 3 on Data Modeling Using the Entity-Relationship Model. Let's briefly recap what we've covered in this **Chapter Summary**.

*   We started by understanding the fundamental **ER Model Concepts**:
    *   **Entities**: The "things" or "objects" in our miniworld.
    *   **Attributes**: The properties that describe entities.
    *   **Relationships**: The associations or interactions between entities.

*   We then delved into the crucial aspect of **Constraints in the ER model**. This included:
    *   Cardinality Ratios (1:1, 1:N, M:N) to define maximum participation.
    *   Participation Constraints (total/mandatory or partial/optional) to define minimum participation.
    *   Weak entity types and their identifying relationships.

*   We saw how to apply these concepts by **Using ER in a step-by-step mode for conceptual schema design**, specifically for our running example, the **COMPANY database**. This involved identifying entities, attributes, relationships, and then refining the model.

*   A significant portion was dedicated to **ER Diagrams - Notation**. We learned the graphical symbols used to represent all these ER model constructs, including the (min,max) notation for precise constraint specification.

*   We broadened our horizons by looking at **Alternative Notations**, with a particular focus on **UML class diagrams**, and saw how they map ER concepts, while also noting other variations exist (as shown in Appendix A).

*   Finally, we discussed **Binary Relationship types** (which are the most common) and also touched upon relationships of **higher degree** (ternary and n-ary relationships) and the complexities and modeling choices associated with them.

This chapter has equipped you with the foundational tools and concepts for conceptual database design. The ability to create clear, accurate, and comprehensive ER diagrams is a vital skill for any database professional. Make sure you practice these concepts, as they will be essential for everything that follows.

Any questions before we conclude for today?