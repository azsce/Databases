---
title: "9. chapter 9"
---

#


## CHAPTER 9: Relational Database Design by ER- and EERR-to-Relational Mapping

Today, we're focusing on Chapter 9, a really crucial chapter. It’s all about "Relational Database Design by ER- and EERR-to-Relational Mapping." Now, that's a bit of a mouthful, but essentially, we're going to learn how to take those conceptual diagrams we’ve been working with – the Entity-Relationship (ER) diagrams and the Enhanced Entity-Relationship (EERR) diagrams – and translate them into a concrete relational database schema. This is the practical step where our abstract designs start to become real database structures.

---
<div class="page-break"></div>

### Chapter Outline

So, what's on the agenda for today? As you can see on the slide, we'll first walk through the **ER-to-Relational Mapping Algorithm**. This is a systematic, step-by-step process.

*   We'll start with **Step 1: Mapping of Regular Entity Types**. These are your standard, strong entities.
*   Then, we'll move to **Step 2: Mapping of Weak Entity Types**, which, as you recall, depend on other entities for their existence.
*   **Step 3** will cover **Mapping of Binary 1:1 Relation Types** – how to handle relationships where one instance of an entity is related to at most one instance of another.
*   **Step 4** addresses **Mapping of Binary 1:N Relationship Types**, which is a very common scenario, like one department having many employees.
*   **Step 5** tackles **Mapping of Binary M:N Relationship Types**, or many-to-many relationships, such as many students enrolling in many courses.
*   In **Step 6**, we'll look at **Mapping of Multivalued attributes**, for when an attribute can hold multiple values for a single entity instance.
*   And **Step 7** deals with **Mapping of N-ary Relationship Types**, which are relationships involving more than two entity types.

After we've covered the basic ER mapping, we'll then expand our scope to **Mapping EER Model Constructs to Relations**. The EER model, remember, adds concepts like specialization and generalization.

*   So, **Step 8** will explore the **Options for Mapping Specialization or Generalization**. We'll see there are several ways to approach this.
*   Finally, **Step 9** will discuss the **Mapping of Union Types (Categories)**, which allow us to model entities that are a union of other, potentially different, entity types.

This structured approach is key to ensuring we create a well-formed and efficient relational database from our conceptual models.

---
<div class="page-break"></div>

### GOALS during Mapping

Now, before we jump into the nitty-gritty of the algorithm, let's talk about our goals. What are we trying to achieve when we perform this mapping from an ER or EER diagram to a relational schema?

*   First and foremost, we want to **Preserve all information**. This is critical. All the attributes we've defined in our conceptual model, all the entities, all the relationships – they all need to find a home in our relational schema. We can't afford to lose any data or meaning during this translation.
*   Secondly, we need to **Maintain the constraints to the extent possible**. Our ER diagrams are rich with constraints – cardinality ratios, participation constraints, and so on. The relational model, while powerful, can't always perfectly represent *every* constraint from an ER model directly. For example, a specific max cardinality like 1:10 in an ER diagram, or an exhaustive classification into subtypes (like all students *must* be either Domestic or Foreign) might require additional application-level logic or more complex database constraints. Our goal is to preserve as many of these as the relational model allows.
*   And thirdly, a very practical goal: **Minimize null values**. Null values can complicate queries and waste space. A good mapping strategy will try to structure the relations in such a way that the occurrence of nulls is reduced.

It's also worth noting, as the slide mentions, that *the mapping procedure described has been implemented in many commercial tools*. This isn't just theoretical; CASE tools (Computer-Aided Software Engineering tools) often use these very algorithms to help automate the process of database design, which is a testament to their practical value.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm

Alright, let's begin with the first step of our ER-to-Relational Mapping Algorithm.

### ■ Step 1: Mapping of Regular Entity Types.

This step deals with your basic, strong entity types. These are the entities that can exist independently and have their own primary key.

*   The rule is: For each regular (or strong) entity type, let's call it `E`, in our ER schema, we will **create a new relation (which is essentially a table) R**. This relation `R` will include all the *simple* attributes of `E`. If `E` has composite attributes, we'll break them down into their simple components and include those.
*   Next, we need to **choose one of the key attributes of E to be the primary key for our new relation R**. Remember, an entity type in an ER diagram might have several candidate keys. We pick one to be the primary key for the table.
*   And what if that chosen key is composite? If the key of `E` is made up of multiple attributes, then that **set of simple attributes will *together* form the primary key of relation R**.

---

■ **Example**: Let's look at a common example. If our ER diagram has regular entities like EMPLOYEE, DEPARTMENT, and PROJECT, we would apply this step to each.
*   We would create an `EMPLOYEE` table, a `DEPARTMENT` table, and a `PROJECT` table.
*   The slide points out that `SSN` would become the primary key for the `EMPLOYEE` table, `DNUMBER` (department number) for the `DEPARTMENT` table, and `PNUMBER` (project number) for the `PROJECT` table. These are assumed to be the chosen key attributes from the ER diagram.

This first step is quite straightforward: one table per strong entity, with its attributes becoming columns and its key becoming the primary key.

---
<div class="page-break"></div>

### Figure 9.1 The ER conceptual schema diagram for the COMPANY database.

Now, let's look at **Figure 9.1** on the slide. This shows an ER conceptual schema diagram for a hypothetical COMPANY database. This is the kind of diagram we'd be starting with.

You can see several entity types:
*   `EMPLOYEE`, with attributes like `Fname`, `Minit`, `Lname`, `Ssn` (which is underlined, indicating it's the key), `Bdate`, `Address`, `Sex`, `Salary`, `Super_ssn` (a foreign key for supervision, which we'll get to), and `Dno` (another foreign key for department).
*   `DEPARTMENT`, with `Dname`, `Dnumber` (key), `Mgr_ssn`, and `Mgr_start_date`.
*   `DEPT_LOCATIONS`, which is a multivalued attribute of `DEPARTMENT`, represented here as an entity. It has `Dnumber` and `Dlocation`. We'll see how to map multivalued attributes soon.
*   `PROJECT`, with `Pname`, `Pnumber` (key), `Plocation`, and `Dnum`.
*   `WORKS_ON`, which is a relationship entity for the M:N relationship between `EMPLOYEE` and `PROJECT`. It has `Essn`, `Pno`, and `Hours`.
*   And `DEPENDENT`, a weak entity, with attributes `Essn` (part of its key, a foreign key to `EMPLOYEE`), `Dependent_name` (the partial key), `Sex`, `Bdate`, and `Relationship`.

On the right side of the slide, you see the more graphical ER diagram notation.
*   `EMPLOYEE` is connected to `DEPARTMENT` via `WORKS_FOR` (N:1) and `MANAGES` (1:1, with total participation from `DEPARTMENT`).
*   `EMPLOYEE` is involved in a recursive `SUPERVISION` relationship (1:N).
*   `EMPLOYEE` is related to `DEPENDENT` via `DEPENDENTS_OF` (1:N, identifying relationship for the weak entity `DEPENDENT`).
*   `DEPARTMENT` controls `PROJECTS` via the `CONTROLS` relationship (1:N).
*   `EMPLOYEE` and `PROJECT` have an M:N relationship `WORKS_ON`, which has an attribute `Hours`.
*   `DEPARTMENT` has a multivalued attribute `Locations`.
*   `EMPLOYEE` has attributes like `Name` (composite: `Fname`, `Minit`, `Lname`), `Ssn`, `Bdate`, `Address`, `Salary`, `Sex`.
*   `PROJECT` has `Name`, `Number`, `Location`.
*   `DEPENDENT` has attributes `Name`, `Sex`, `Birth_date`, `Relationship`.

This diagram sets the stage for the mapping steps we're about to discuss. Keep this COMPANY schema in mind as we go through the examples.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm (contd.)

Let's proceed to the second step in our algorithm.

### ■ Step 2: Mapping of Weak Entity Types

Recall that a weak entity type does not have enough attributes to form its own primary key; it depends on an "owner" entity type.

*   So, for each **weak entity type W** in the ER schema, which has an **owner entity type E**, we again **create a relation R**. This relation R will include all the simple attributes (or simple components of composite attributes) of W as attributes of R.
*   Crucially, we must also **include as foreign key attributes in R the primary key attribute(s) of the relation(s) that correspond to the owner entity type(s) E**. This establishes the link and the dependency.
*   The **primary key of this new relation R** for the weak entity is then the **combination of the primary key(s) of the owner(s) AND the partial key of the weak entity type W**, if W has one.

---

■ **Example**: Let's go back to our COMPANY schema from Figure 9.1. We have the weak entity type `DEPENDENT`.
*   We will create a relation called `DEPENDENT`.
*   Following the rule, we include the primary key of its owner, `EMPLOYEE`. The primary key of `EMPLOYEE` is `Ssn`. In the `DEPENDENT` relation, this might be renamed, for example, to `ESSN` (Employee SSN), and it will be a foreign key referencing the `EMPLOYEE` table.
*   The `DEPENDENT` entity has a partial key, `DEPENDENT_NAME`.
*   Therefore, the **primary key of the `DEPENDENT` relation will be the combination {`ESSN`, `DEPENDENT_NAME`}**. This makes sense because a dependent is identified by who they belong to (the employee via `ESSN`) and their own name within that family.

This step ensures that weak entities are correctly represented and linked to their identifying strong entities.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm (contd.)

Now we move on to mapping relationship types. Let's start with binary 1-to-1 relationships.

### Step 3: Mapping of Binary 1:1 Relation Types

*   For each binary 1:1 relationship type `R` in our ER schema, we first identify the relations, let's call them `S` and `T`, that correspond to the entity types participating in this relationship `R`. So, we've already created tables for these entities in Step 1.

■ **There are three possible approaches** to mapping these 1:1 relationships:

1.  **Foreign Key (2 relations) approach**: This is a very common way.
    *   You choose one of the relations, say `S`, and include a foreign key in `S` that references the primary key of the other relation, `T`.
    *   A good heuristic here is to choose the entity type that has **total participation** in the relationship `R` to be the one (our `S`) that gets the foreign key. This helps minimize null values, because if `S` *must* participate, then the foreign key in `S` will always have a value.
    *   **Example**: In our COMPANY schema (Figure 9.1), there's a 1:1 relationship `MANAGES` between `EMPLOYEE` and `DEPARTMENT`. An employee manages a department, and a department is managed by one employee. The `DEPARTMENT` entity has total participation (every department must be managed). So, it's better to put the foreign key in the `DEPARTMENT` table. We would add `Mgr_ssn` (manager's SSN, which is the primary key of `EMPLOYEE`) as a foreign key in the `DEPARTMENT` table. The slide gives the example of choosing the `DEPARTMENT` entity type to serve in the role of `S`.

2.  **Merged relation (1 relation) option**:
    *   An alternative for 1:1 relationships is to merge the two entity types *and* the relationship into a single relation (a single table).
    *   This option is most appropriate when **both participations are total**. If both entities *must* participate in the relationship, merging them can be efficient. However, if participation is partial on one or both sides, merging would lead to many null values for the attributes of the partially participating entity.

3.  **Cross-reference or relationship relation (3 relations) option**:
    *   The third alternative is to create a *third* relation, specifically for the relationship `R`. This new relation would essentially cross-reference the primary keys of the two participating relations, `S` and `T`. So, this relationship table would have foreign keys pointing to `S` and `T`.
    *   This option is always possible but often creates an extra table, which might not be necessary for 1:1 relationships unless the relationship itself has attributes.

The choice among these options depends on the specifics of the relationship, especially the participation constraints, and whether the relationship has its own attributes. The foreign key approach is often preferred for its simplicity and efficiency when one side has total participation.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm (contd.)

Next up is Step 4, dealing with another very common type of relationship.

### ■ Step 4: Mapping of Binary 1:N Relationship Types.

This is for one-to-many relationships.

*   For each regular binary 1:N relationship type `R`, we first identify the relation, let's call it `S`, that represents the participating entity type on the **N-side** (the "many" side) of the relationship.
*   Then, we **include as a foreign key in this relation `S` (the N-side table) the primary key of the relation `T`** that represents the other entity type participating in `R` (the "one" side).
*   If the 1:N relationship itself has any simple attributes, these are also **included as attributes of `S`** (the N-side table).

This approach is quite intuitive: the entity on the "many" side gets a foreign key pointing to the entity on the "one" side.

---

■ **Example**: Let's consider the 1:N relationship types `WORKS_FOR`, `CONTROLS`, and `SUPERVISION` from our COMPANY ER diagram (Figure 9.1).
*   For the `WORKS_FOR` relationship (Employee WORKS_FOR Department, N:1), the `EMPLOYEE` entity is on the N-side. So, we include the primary key of `DEPARTMENT` (which is `Dnumber`) as a foreign key in the `EMPLOYEE` relation. The slide notes this might be called `Dno` in the `EMPLOYEE` table.
*   Similarly, for `CONTROLS` (Department CONTROLS Project, 1:N), `PROJECT` is on the N-side. So, the `PROJECT` table would get a foreign key referencing `DEPARTMENT`'s primary key.
*   For `SUPERVISION` (Employee SUPERVISES Employee, 1:N, a recursive relationship), the "supervised" employee is on the N-side. So, the `EMPLOYEE` table would have a foreign key (like `Super_ssn`) that references its own primary key (`Ssn`) to indicate the supervisor.

■ The slide also mentions an alternative: "An alternative approach is to use a Relationship relation (cross referencing relation) – this is rarely done."
For a 1:N relationship, creating a separate table just for the relationship (like we might for M:N) is generally not efficient. It introduces an extra join for most queries. The foreign key approach on the N-side is the standard and most efficient method.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm (contd.)

Now, let's tackle Step 5, which addresses many-to-many relationships.

### Step 5: Mapping of Binary M:N Relationship Types.

For M:N relationships, where an instance of one entity can be related to multiple instances of another, and vice-versa.

*   For each regular binary M:N relationship type `R`, we **create a *new* relation `S` to represent `R`**. This is important: M:N relationships *always* result in a new table. This new table is often called a `relationship relation`, an `associative table`, or a `junction table`.
*   This new relation `S` will **include as foreign key attributes the primary keys of the relations that represent the participating entity types**. These foreign keys link back to the original entity tables.
*   The **combination of these foreign key attributes will typically form the primary key of the new relation `S`**.
*   If the M:N relationship itself has any attributes (descriptive attributes of the relationship), these are also **included as attributes of this new relation `S`**.

---

■ **Example**: Let's look at the M:N relationship type `WORKS_ON` from our COMPANY ER diagram (Figure 9.1). This relationship is between `EMPLOYEE` and `PROJECT` (an employee can work on many projects, and a project can have many employees).
*   We will map this by creating a **new relation called `WORKS_ON`**.
*   The primary keys of the `EMPLOYEE` relation (`Ssn`) and the `PROJECT` relation (`Pnumber`) are included as foreign keys in this `WORKS_ON` table. The slide notes they might be renamed, for example, to `ESSN` and `PNO`, respectively.
*   The `WORKS_ON` relationship in the ER diagram has an attribute `Hours` (representing the number of hours an employee works on a particular project). This `Hours` attribute becomes an attribute in our new `WORKS_ON` relation.
*   The **primary key of this new `WORKS_ON` relation will be the combination of the foreign key attributes {`ESSN`, `PNO`}**. This uniquely identifies each instance of an employee working on a specific project.

This method of creating a new table is the standard way to resolve M:N relationships into a relational schema, as relational databases don't directly support many-to-many connections between two tables without an intermediary.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm (contd.)

Moving on to Step 6, which deals with a specific type of attribute.

### Step 6: Mapping of Multivalued attributes.

Remember, a multivalued attribute is one that can hold multiple values for a single entity instance (e.g., an employee having multiple skills, or a department having multiple locations). Standard relational tables don't allow a single cell to hold multiple values.

*   So, for each **multivalued attribute A**, we **create a *new* relation R**.
*   This new relation `R` will include an **attribute corresponding to A** (to hold one value of the multivalued attribute per row).
*   It will also include the **primary key attribute K of the relation that represents the entity type (or relationship type) that *has* A as an attribute**. This `K` will serve as a **foreign key in R**, linking back to the original entity.
*   The **primary key of this new relation R will be the combination of A and K**. If the multivalued attribute `A` itself is composite, then we include its simple components in the relation `R`, and these components, along with `K`, would form the primary key.

Essentially, we're taking the set of multiple values and "flattening" it out into a separate table, where each row represents one specific value for a given entity instance.

---

■ **Example**: In our COMPANY ER diagram (Figure 9.1), the `DEPARTMENT` entity has a multivalued attribute `LOCATIONS`. A department can be in multiple locations.
*   To map this, we **create a new relation, say `DEPT_LOCATIONS`**.
*   The attribute `DLOCATION` in this new table will represent the multivalued attribute `LOCATIONS` (so each row in `DEPT_LOCATIONS` will store one specific location).
*   We also include `DNUMBER` (the primary key of the `DEPARTMENT` relation) as a foreign key in `DEPT_LOCATIONS`. This links each location back to its department.
*   The **primary key of this `DEPT_LOCATIONS` relation will be the combination {`DNUMBER`, `DLOCATION`}**. This ensures that each department-location pair is unique.

This method ensures that we adhere to the first normal form (1NF) in database design, which states that attribute values must be atomic.

---
<div class="page-break"></div>

## ER-to-Relational Mapping Algorithm (contd.)

Now for Step 7, which handles relationships involving more than two entity types.

### Step 7: Mapping of N-ary Relationship Types.

An n-ary relationship is one where `n` entity types participate (and `n` is greater than 2, so ternary, quaternary, etc.).

*   For each **n-ary relationship type R**, where n > 2, we **create a *new* relationship (table) S to represent R**. Similar to M:N relationships, n-ary relationships always result in a new table.
*   We then **include as foreign key attributes in S the primary keys of all the relations that represent the participating entity types**. So, if it's a ternary relationship, there will be three foreign keys in `S`.
*   If the n-ary relationship itself has any simple attributes (or simple components of composite attributes), these are also **included as attributes of S**.
*   The primary key of this new relation `S` is typically the combination of all the foreign keys that reference the participating entity types. However, depending on the cardinalities involved in the n-ary relationship, sometimes a subset of these foreign keys might be sufficient to form the primary key.

---

■ **Example**: The slide refers to "The relationship type `SUPPY` in the ER on the next slide." We'll see that diagram shortly (Figure 3.17, it seems). Let's assume `SUPPLY` is a ternary relationship involving, say, `SUPPLIER`, `PART`, and `PROJECT` (a supplier supplies a certain part to a certain project).
*   This `SUPPLY` relationship would be mapped to a **new relation called `SUPPLY`**.
*   This `SUPPLY` table would include foreign keys for the primary keys of `SUPPLIER` (e.g., `SNAME`), `PART` (e.g., `PARTNO`), and `PROJECT` (e.g., `PROJNAME`).
*   The primary key of the `SUPPLY` relation would then be the **combination of these three foreign keys: {`SNAME`, `PARTNO`, `PROJNAME`}**.
*   If the `SUPPLY` relationship had its own attributes (like `Quantity`), those would also be columns in the `SUPPLY` table.

Mapping n-ary relationships always involves creating a new table to capture the connections between all participating entities.

---
<div class="page-break"></div>

### Figure 9.2 Result of mapping the COMPANY ER schema into a relational database schema.

Okay, let's look at **Figure 9.2**. This slide shows the **result of mapping the COMPANY ER schema (from Figure 9.1) into a relational database schema**, applying the steps we've just discussed. This is the "after" picture.

You can see the following relations (tables) have been created:

*   **`EMPLOYEE`**:
    *   Columns: `Fname`, `Minit`, `Lname`, `Ssn` (Primary Key), `Bdate`, `Address`, `Sex`, `Salary`, `Super_ssn` (Foreign Key referencing `EMPLOYEE.Ssn`), `Dno` (Foreign Key referencing `DEPARTMENT.Dnumber`).
    *   This came from mapping the `EMPLOYEE` strong entity (Step 1), and also includes foreign keys from 1:N relationships (`WORKS_FOR`, `SUPERVISION` - Step 4).

*   **`DEPARTMENT`**:
    *   Columns: `Dname`, `Dnumber` (Primary Key), `Mgr_ssn` (Foreign Key referencing `EMPLOYEE.Ssn`), `Mgr_start_date`.
    *   From mapping the `DEPARTMENT` strong entity (Step 1), and includes the foreign key from the 1:1 `MANAGES` relationship (Step 3, foreign key approach). `Mgr_start_date` is an attribute of the `MANAGES` relationship.

*   **`DEPT_LOCATIONS`**:
    *   Columns: `Dnumber` (Part of PK, FK referencing `DEPARTMENT.Dnumber`), `Dlocation` (Part of PK).
    *   This table was created to handle the multivalued attribute `Locations` of `DEPARTMENT` (Step 6).

*   **`PROJECT`**:
    *   Columns: `Pname`, `Pnumber` (Primary Key), `Plocation`, `Dnum` (Foreign Key referencing `DEPARTMENT.Dnumber`).
    *   From mapping the `PROJECT` strong entity (Step 1), and includes the foreign key from the 1:N `CONTROLS` relationship (Step 4).

*   **`WORKS_ON`**:
    *   Columns: `Essn` (Part of PK, FK referencing `EMPLOYEE.Ssn`), `Pno` (Part of PK, FK referencing `PROJECT.Pnumber`), `Hours`.
    *   This table was created to map the M:N `WORKS_ON` relationship between `EMPLOYEE` and `PROJECT` (Step 5). `Hours` is an attribute of that relationship.

*   **`DEPENDENT`**:
    *   Columns: `Essn` (Part of PK, FK referencing `EMPLOYEE.Ssn`), `Dependent_name` (Part of PK), `Sex`, `Bdate`, `Relationship`.
    *   This table maps the weak entity `DEPENDENT` (Step 2). `Essn` comes from the owner `EMPLOYEE`, and `Dependent_name` is the partial key.

The arrows on the diagram illustrate the foreign key relationships. For example, an arrow from `EMPLOYEE.Dno` points to `DEPARTMENT.Dnumber`, indicating that `Dno` in `EMPLOYEE` refers to an existing `Dnumber` in `DEPARTMENT`.

This visual summary is very helpful to see how the various ER constructs translate into a set of interconnected relational tables.

---
<div class="page-break"></div>

### FIGURE 3.17 TERNARY RELATIONSHIP: SUPPLY

Alright, as mentioned in Step 7, here's **Figure 3.17**, which illustrates a **Ternary Relationship: SUPPLY**.
The diagram (labeled (a)) shows:
*   Three entity types: `SUPPLIER`, `PART`, and `PROJECT`.
    *   `SUPPLIER` has an attribute `SName` (likely its key).
    *   `PART` has an attribute `PartNo` (likely its key).
    *   `PROJECT` has an attribute `ProjName` (likely its key).
*   These three entities are connected via a diamond shape labeled `SUPPLY`, representing the ternary relationship.
*   The `SUPPLY` relationship itself has an attribute `Quantity`.

The meaning here is that a specific `SUPPLIER` supplies a specific `PART` for a specific `PROJECT`, and the `Quantity` attribute tells us how many of that part are supplied by that supplier for that project.

This is the kind of n-ary relationship that Step 7 of our mapping algorithm addresses. The next slide will show how this is mapped.

---
<div class="page-break"></div>

### Mapping the *n*-ary relationship type SUPPLY

Following up on the previous slide, this one shows the **Mapping of the *n*-ary relationship type SUPPLY** into relational tables.

We see four relations depicted:

1.  **`SUPPLIER`** relation:
    *   It has a column `Sname` (which would be its primary key) and then "..." indicating other supplier-specific attributes.

2.  **`PROJECT`** relation:
    *   It has a column `Proj_name` (its primary key) and "..." for other project attributes.

3.  **`PART`** relation:
    *   It has a column `Part_no` (its primary key) and "..." for other part attributes.

These three tables (`SUPPLIER`, `PROJECT`, `PART`) would have been created according to Step 1 of our mapping algorithm (mapping regular entity types).

4.  **`SUPPLY`** relation:
    *   This is the new table created to map the ternary `SUPPLY` relationship, as per Step 7.
    *   It contains columns:
        *   `Sname` (a foreign key referencing `SUPPLIER.Sname`)
        *   `Proj_name` (a foreign key referencing `PROJECT.Proj_name`)
        *   `Part_no` (a foreign key referencing `PART.Part_no`)
        *   `Quantity` (this was the attribute of the `SUPPLY` relationship itself).
    *   The primary key for this `SUPPLY` table would be the combination of {`Sname`, `Proj_name`, `Part_no`}.

The arrows show the foreign key dependencies: `SUPPLY.Sname` points to `SUPPLIER.Sname`, `SUPPLY.Proj_name` points to `PROJECT.Proj_name`, and `SUPPLY.Part_no` points to `PART.Part_no`.

This clearly illustrates how a ternary relationship is broken down: the participating entities become tables (if not already), and the relationship itself becomes a new table linking them together, holding any attributes of the relationship.

---
<div class="page-break"></div>

### Summary of Mapping constructs and constraints

This slide, **Table 9.1**, provides a very useful **Summary of Mapping Constructs and Constraints**. It shows the correspondence between concepts in the ER Model and how they are typically represented in the Relational Model. Let's go through it:

*   **ER MODEL:** `Entity type`
    *   **RELATIONAL MODEL:** Becomes an `Entity relation` (which is essentially a table). This was our Step 1 and Step 2.

*   **ER MODEL:** `1:1 or 1:N relationship type`
    *   **RELATIONAL MODEL:** Typically handled by a `Foreign key`. For 1:1, we also saw the option of a *relationship relation* (though less common) or merging. For 1:N, the foreign key is placed on the N-side. (Steps 3 and 4)

*   **ER MODEL:** `M:N relationship type`
    *   **RELATIONAL MODEL:** This always becomes a `Relationship relation` (a new table) and involves *two* foreign keys (one for each participating entity). (Step 5)

*   **ER MODEL:** `n-ary relationship type`
    *   **RELATIONAL MODEL:** Similar to M:N, this becomes a `Relationship relation` and will have *n* foreign keys (one for each of the n participating entities). (Step 7)

*   **ER MODEL:** `Simple attribute`
    *   **RELATIONAL MODEL:** Directly becomes an `Attribute` (a column in a table).

*   **ER MODEL:** `Composite attribute`
    *   **RELATIONAL MODEL:** Is represented as a `Set of simple component attributes`. We break it down into its constituent simple attributes, each becoming a column.

*   **ER MODEL:** `Multivalued attribute`
    *   **RELATIONAL MODEL:** Requires a new `Relation` (table) and a `foreign key` linking back to the original entity's table. (Step 6)

*   **ER MODEL:** `Value set` (the set of allowed values for an attribute)
    *   **RELATIONAL MODEL:** Corresponds to a `Domain` for an attribute (column). The data type of the column and any check constraints help enforce this.

*   **ER MODEL:** `Key attribute` (like a primary key or candidate key in ER)
    *   **RELATIONAL MODEL:** Becomes a `Primary (or secondary) key` in the table.

This table is a great quick reference for the entire ER-to-Relational mapping process we've covered so far for basic ER constructs. It encapsulates the core transformations.

---
<div class="page-break"></div>

## Mapping of Generalization and Specialization Hierarchies to a Relational Schema

Alright, we've covered the mapping of basic ER model constructs. Now, we're going to shift our focus to the Enhanced Entity-Relationship (EER) model. Specifically, we'll look at how to map **Generalization and Specialization Hierarchies** to a Relational Schema.

Remember, generalization and specialization allow us to model superclass/subclass relationships, like `EMPLOYEE` being a superclass for `SECRETARY`, `TECHNICIAN`, and `ENGINEER`. This introduces some new considerations for our mapping process.

---
<div class="page-break"></div>

## Mapping EER Model Constructs to Relations

So, let's dive into how we map these EER constructs. This brings us to Step 8 of our overall mapping algorithm.

### Step 8: Options for Mapping Specialization or Generalization.

When we have a specialization (or generalization) in our EER diagram, with a superclass `C` and a set of, say, `m` subclasses `{S1, S2, ..., Sm}`, we need to convert this structure into relational schemas.
Let's assume the superclass `C` has attributes `{k, a1, ..., an}`, where `k` is its primary key.

The key thing here is that there isn't just one way to do this. We have several **options**, and the best choice often depends on the specific characteristics of the specialization (like whether it's total or partial, disjoint or overlapping) and performance considerations.

The slide lists four main options:

*   **Option 8A: Multiple relations - Superclass and subclasses**
    *   Here, we create one table for the superclass and separate tables for each of the subclasses.

*   **Option 8B: Multiple relations - Subclass relations only**
    *   In this approach, we only create tables for the subclasses. The attributes of the superclass are replicated in each subclass table.

*   **Option 8C: Single relation with one type attribute**
    *   This option involves creating just one single table that includes attributes for the superclass *and* all possible attributes from *all* subclasses. A special "type" attribute is used to indicate which subclass a particular row belongs to.

*   **Option 8D: Single relation with multiple type attributes**
    *   Similar to 8C, this also uses a single table. However, instead of one type attribute, it uses multiple Boolean (true/false) type attributes, one for each subclass, to indicate membership.

We'll explore each of these options in more detail.

---
<div class="page-break"></div>

## Mapping EER Model Constructs to Relations (Continued)

Let's break down the first two options for mapping specialization/generalization.

### ■ Option 8A: Multiple relations-Superclass and subclasses

This is a very common and intuitive approach.
*   First, you **create a relation L for the superclass C**. This table `L` will have all the attributes of the superclass, so `Attrs(L) = {k, a1, ..., an}`, and its primary key `PK(L)` will be `k` (the primary key of the superclass).
*   Then, for **each subclass Si** (where `i` goes from 1 to `m`), you **create a separate relation Li**.
    *   The attributes of this subclass table `Li`, `Attrs(Li)`, will be the primary key of the superclass, `{k}`, *plus* all the specific attributes of that particular subclass `Si`.
    *   The primary key of each subclass table `Li`, `PK(Li)`, will also be `k`. This `k` in the subclass table `Li` also serves as a foreign key referencing the superclass table `L`.

*   **When is this option suitable?** The slide notes: "This option works for any specialization (total or partial, disjoint or overlapping)." This makes it very versatile.
    *   If an entity is *only* in the superclass and not in any subclass (in a partial specialization), it will just have a row in the superclass table.
    *   If an entity belongs to a subclass, it will have a row in the superclass table (for the common attributes) AND a row in the specific subclass table (for its specialized attributes), linked by the common primary key `k`.
    *   If it's an overlapping specialization (an entity can be in multiple subclasses), it would have a row in the superclass table and rows in *each* of the subclass tables it belongs to.

---

### ■ Option 8B: Multiple relations-Subclass relations only

This option takes a different route by eliminating the superclass table.
*   Here, you **create a relation Li for each subclass Si** (again, `i` from 1 to `m`).
*   The attributes of this subclass table `Li`, `Attr(Li)`, will include **all the specific attributes of that subclass Si *PLUS all the attributes of the superclass C***, so `{attributes of Si}` U `{k, a1, ..., an}`.
*   The primary key `PK(Li)` for each subclass table will still be `k` (the original superclass primary key).

*   **When is this option suitable?** The slide states: "This option only works for a specialization whose subclasses are **total**." This is a crucial restriction. "Total" means every entity in the superclass *must* belong to (at least) one of the subclasses.
    *   If the specialization is total, then every superclass instance will also be an instance of at least one subclass, so there's no information lost by not having a separate superclass table. All the superclass attributes are just repeated in each subclass table.
    *   If the specialization were partial, using this option would mean you couldn't represent entities that belong *only* to the superclass and not to any specific subclass.

This option can reduce joins if you often query subclass-specific information along with superclass attributes, but it introduces redundancy of the superclass attributes across multiple tables.

We'll look at examples of these soon.

---
<div class="page-break"></div>

## Mapping EER Model Constructs to Relations (contd.)

Now let's look at the other two main options for mapping specialization and generalization, Options 8C and 8D, which both involve using a single relation.

### ■ Option 8C: Single relation with one type attribute

This approach aims to consolidate everything into one table.
*   You **create a single relation L** (one table).
*   The attributes of this single relation `L`, `Attrs(L)`, will be:
    *   All attributes of the superclass: `{k, a₁, ..., an}`
    *   *Union* all attributes of the first subclass S₁: `U {attributes of S₁}`
    *   *Union* all attributes of all other subclasses, up to Sm: `U ... U {attributes of Sm}`
    *   *Plus* a special new attribute, let's call it `t`: `U {t}`.
*   The primary key `PK(L)` of this single table will be `k` (the superclass primary key).
*   The special attribute `t` is called a **type attribute** (or sometimes a `discriminating` attribute or `tag`). Its purpose is to **indicate the subclass to which each tuple (row) belongs**. For example, if you have subclasses `SECRETARY`, `ENGINEER`, `TECHNICIAN`, the `t` attribute might store values like 'S', 'E', or 'T'.

*   **Considerations for Option 8C**:
    *   This option can be efficient if you frequently query attributes across different subclasses or from the superclass and subclasses together, as it avoids joins.
    *   However, it can lead to many **null values**. If a particular row represents an `ENGINEER`, then all the attributes specific to `SECRETARY` or `TECHNICIAN` in that row will be null. This can waste space and complicate queries (e.g., needing `IS NOT NULL` checks).
    *   This option is generally more suitable for **disjoint** specializations (where an entity can belong to at most one subclass). If it's overlapping, representing multiple subclass memberships with a single type attribute becomes tricky.

---

### ■ Option 8D: Single relation with multiple type attributes

This is a variation of the single-relation approach, also aiming to use one table, but it handles overlapping specializations more naturally.
*   Again, you **create a single relation schema L**.
*   The attributes `Attrs(L)` will be:
    *   All attributes of the superclass: `{k, a₁, ..., an}`
    *   *Union* all attributes of S₁: `U {attributes of S₁}`
    *   *Union* all attributes of all other subclasses, up to Sm: `U ... U {attributes of Sm}`
    *   *Plus* a set of **multiple type attributes**: `U {t₁, t₂, ..., tm}`. There's one `ti` for each subclass `Si`.
*   The primary key `PK(L)` is still `k`.
*   Each `ti` (where `i` goes from 1 to `m`) is a **Boolean type attribute** (e.g., True/False, or 1/0). It **indicates whether a tuple belongs to the subclass Si**. For example, you might have `IsSecretary` (True/False), `IsEngineer` (True/False), etc.

*   **Considerations for Option 8D**:
    *   Like 8C, this avoids joins but can also lead to many null values for the subclass-specific attributes.
    *   This option is well-suited for **overlapping** specializations because an entity can have 'True' for multiple `ti` flags if it belongs to multiple subclasses.
    *   It's also fine for disjoint specializations (in which case, only one `ti` would be true for any given row representing a subclass member).

The choice between 8A, 8B, 8C, and 8D depends heavily on the nature of the specialization (total/partial, disjoint/overlapping), the types of queries expected, and the trade-offs between joins, redundancy, and null values.

Let's look at some figures to make these options clearer.


---

## Mapping EER Model Constructs to Relations (contd.) - Visual Examples

### FIGURE 4.4 EER diagram notation for an attribute-defined specialization on JobType.

Now, let's look at **Figure 4.4**. This EER diagram shows an "attribute-defined specialization" on an attribute called `JobType`.

*   We have a superclass `EMPLOYEE`. Its attributes include `FName`, `MInit`, `LName` (which form a composite `Name`), `Ssn` (the primary key), `BirthDate`, `Address`, and importantly, `JobType`.
*   The `JobType` attribute is the **defining attribute** for the specialization. This means the value of `JobType` determines which subclass an employee belongs to.
*   The specialization is represented by a circle with a 'd' inside it (for disjoint), connected to three subclasses:
    *   `SECRETARY`: This subclass is defined by `JobType = "Secretary"`. It has a specific attribute `TypingSpeed`.
    *   `TECHNICIAN`: Defined by `JobType = "Technician"`. It has a specific attribute `TGrade` (Technician Grade).
    *   `ENGINEER`: Defined by `JobType = "Engineer"`. It has a specific attribute `EngType` (Engineer Type).

This is a classic example of a disjoint, attribute-defined specialization. An employee is either a Secretary, a Technician, or an Engineer (or possibly none of them if the specialization is partial, though `JobType` as a defining attribute often implies total specialization into one of these categories if `JobType` must be one of these values).

We'll use this EER diagram to illustrate how some of our mapping options (8A, 8C) would look.

---
<div class="page-break"></div>

### Mapping the EER schema in Figure 4.4 using option 8A

Here on this slide, labeled (a), we see how the EER schema from **Figure 4.4 (the EMPLOYEE specialization) is mapped using Option 8A: Multiple relations - Superclass and subclasses.**

*   **`EMPLOYEE` Relation (Superclass Table):**
    *   Created with columns: `SSN` (Primary Key), `FName`, `MInit`, `LName`, `BirthDate`, `Address`, and `JobType`.
    *   This table stores all the common attributes for all employees.

*   **`SECRETARY` Relation (Subclass Table):**
    *   Created with columns: `SSN` (Primary Key and Foreign Key referencing `EMPLOYEE.SSN`) and `TypingSpeed`.
    *   Only employees who are secretaries will have an entry here. Their `SSN` links them to their general information in the `EMPLOYEE` table.

*   **`TECHNICIAN` Relation (Subclass Table):**
    *   Created with columns: `SSN` (Primary Key and Foreign Key referencing `EMPLOYEE.SSN`) and `TGrade`.
    *   Only for technicians.

*   **`ENGINEER` Relation (Subclass Table):**
    *   Created with columns: `SSN` (Primary Key and Foreign Key referencing `EMPLOYEE.SSN`) and `EngType`.
    *   Only for engineers.

So, if you have an employee who is an engineer, there will be one row for them in the `EMPLOYEE` table (with their general details and `JobType` = "Engineer") and one row in the `ENGINEER` table (with their `SSN` and `EngType`). If an employee is just a general employee and not one of these specialized types (assuming partial specialization was allowed), they would only have an entry in the `EMPLOYEE` table.

This option is clean, avoids redundancy of common attributes (they are only in the `EMPLOYEE` table), and handles partial specialization well. The `JobType` attribute in the `EMPLOYEE` table is somewhat redundant if the specialization is disjoint and total *and* you always join to the subclass tables, but it's often kept for clarity or if direct queries on `JobType` are common.

---
<div class="page-break"></div>

### Mapping the EER schema in Figure 4.4 using option 8C

Now, let's look at the same EER schema from **Figure 4.4 (the EMPLOYEE specialization) but this time mapped using Option 8C: Single relation with one type attribute.** This is shown on the slide labeled (c).

*   **`EMPLOYEE` Relation (Single Table):**
    *   Only one table is created.
    *   Columns include:
        *   All superclass attributes: `SSN` (Primary Key), `FName`, `MInit`, `LName`, `BirthDate`, `Address`.
        *   The discriminating attribute: `JobType`. (This acts as our 'type' attribute `t` from the general description of Option 8C).
        *   *All* attributes from *all* subclasses: `TypingSpeed` (from `SECRETARY`), `TGrade` (from `TECHNICIAN`), and `EngType` (from `ENGINEER`).

*   **How it works:**
    *   If an employee is a Secretary (so `JobType` = "Secretary"), then the `TypingSpeed` column would have a value, but `TGrade` and `EngType` for that row would be NULL.
    *   If an employee is an Engineer (`JobType` = "Engineer"), then `EngType` would have a value, but `TypingSpeed` and `TGrade` would be NULL.
    *   And similarly for Technicians.

*   **Pros and Cons:**
    *   **Pro:** No joins are needed if you want to retrieve, say, an engineer's name and their engineering type. It's all in one table.
    *   **Con:** Potential for many NULL values. For every secretary, the `TGrade` and `EngType` columns are empty. For every engineer, `TypingSpeed` and `TGrade` are empty. This can waste space and make queries a bit more complex (e.g., "SELECT ... WHERE JobType = 'Engineer' AND EngType IS NOT NULL").
    *   This option is generally better suited for disjoint specializations like this one. The `JobType` attribute naturally serves as the single type attribute.

You can see the trade-offs clearly here: Option 8A uses more tables but has fewer nulls and less redundancy of subclass attributes. Option 8C uses one table, potentially faster for some queries, but with more nulls.

---
<div class="page-break"></div>

### FIGURE 4.3 (b) Generalizing CAR and TRUCK into the superclass VEHICLE.

Let's switch gears to another example, shown in **Figure 4.3 (b)**. This illustrates **Generalization**, where we identify commonalities between existing entity types (`CAR` and `TRUCK`) and create a more general superclass (`VEHICLE`).

*   **Diagram (a) - Before Generalization (Conceptual):**
    *   Imagine we initially modeled `CAR` and `TRUCK` as separate entities.
    *   `CAR` has attributes like `Max_speed`, `No_of_passengers`, `Vehicle_id` (its key), `License_plate_no`, and `Price`.
    *   `TRUCK` has attributes like `No_of_axles`, `Tonnage`, `Vehicle_id` (its key), `License_plate_no`, and `Price`.
    *   We can see common attributes: `Vehicle_id`, `License_plate_no`, `Price`.

*   **Diagram (b) - After Generalization:**
    *   We create a new superclass `VEHICLE`.
    *   The common attributes (`Vehicle_id`, `License_plate_no`, `Price`) are moved to the `VEHICLE` superclass. `Vehicle_id` becomes the primary key of `VEHICLE`.
    *   `CAR` becomes a subclass of `VEHICLE`. It retains its specific attributes: `Max_speed` and `No_of_passengers`.
    *   `TRUCK` also becomes a subclass of `VEHICLE`. It retains its specific attributes: `No_of_axles` and `Tonnage`.
    *   The circle with 'd' indicates this is a disjoint specialization (a vehicle is either a car or a truck, not both). It's also likely a total specialization if all vehicles must be either cars or trucks.

This generalization helps to reduce redundancy and model shared characteristics more effectively. Now let's see how this might be mapped.

---
<div class="page-break"></div>

### Mapping the EER schema in Figure 4.3b using option 8B.

This slide, labeled (b), shows how the `VEHICLE` generalization from **Figure 4.3b is mapped using Option 8B: Multiple relations - Subclass relations only.**

Recall that Option 8B is suitable when the specialization/generalization is **total** (every superclass instance must be one of the subclasses). Assuming our `VEHICLE` generalization is total (i.e., every vehicle is either a `CAR` or a `TRUCK`), this option can be applied.

*   **No `VEHICLE` Table:** Notice there's no separate table for the `VEHICLE` superclass.

*   **`CAR` Relation (Subclass Table):**
    *   Columns:
        *   `VehicleId` (Primary Key, originally from `VEHICLE`)
        *   `LicensePlateNo` (Attribute from `VEHICLE`)
        *   `Price` (Attribute from `VEHICLE`)
        *   `MaxSpeed` (Specific attribute of `CAR`)
        *   `NoOfPassengers` (Specific attribute of `CAR`)
    *   This table contains all attributes of a car, both those inherited from `VEHICLE` and its own specific ones.

*   **`TRUCK` Relation (Subclass Table):**
    *   Columns:
        *   `VehicleId` (Primary Key, originally from `VEHICLE`)
        *   `LicensePlateNo` (Attribute from `VEHICLE`)
        *   `Price` (Attribute from `VEHICLE`)
        *   `NoOfAxles` (Specific attribute of `TRUCK`)
        *   `Tonnage` (Specific attribute of `TRUCK`)
    *   Similarly, this table contains all attributes of a truck.

*   **How it works:**
    *   If you want information about a car, you query the `CAR` table.
    *   If you want information about a truck, you query the `TRUCK` table.
    *   If you want information about *all* vehicles (e.g., all `VehicleId`s and `Price`s), you would need to query both tables and then combine the results using a `UNION` operation, which can be less efficient than if there was a `VEHICLE` superclass table (as in Option 8A).

*   **Pros and Cons:**
    *   **Pro:** If you almost always query cars separately from trucks, this can be efficient as all information for a car (or truck) is in one table, avoiding joins to a superclass table.
    *   **Con:** Superclass attributes (`VehicleId`, `LicensePlateNo`, `Price`) are redundant, appearing in both the `CAR` and `TRUCK` tables. This can lead to update anomalies if not managed carefully (though foreign keys aren't directly involved here in the same way as 8A, the consistency of shared primary keys is vital). Queries on all vehicles become more complex.
    *   **Restriction:** Only works well if the generalization is **total**. If some vehicles were neither cars nor trucks, you'd have nowhere to store them with this option.

This option prioritizes direct access to subclass information at the cost of some redundancy and complexity for superclass-level queries.

---
<div class="page-break"></div>

### FIGURE 4.5 An overlapping (non-disjoint) specialization.

Let's look at another EER construct in **Figure 4.5**: an **overlapping (non-disjoint) specialization**.

*   We have a superclass `PART`. Its attributes are `Part_no` (the primary key) and `Description`.
*   This `PART` entity can be specialized into two subclasses:
    *   `MANUFACTURED_PART`: This subclass has attributes `Manufacture_date`, `Batch_no`, and `Drawing_no`.
    *   `PURCHASED_PART`: This subclass has attributes `Supplier_name` and `List_price`.
*   The key here is the circle connecting `PART` to its subclasses. It's empty or might have an 'o' for overlapping. This means a single `PART` can be *both* a `MANUFACTURED_PART` *and* a `PURCHASED_PART` simultaneously. For example, a company might manufacture a part internally but also purchase the same part from an external supplier as a backup or to meet high demand.

This "overlapping" nature requires careful consideration during mapping, as options that assume disjointness (like a single type attribute in Option 8C if not handled carefully) might not work well. Option 8D, with multiple Boolean flags, is often a good fit for overlapping specializations if a single table is desired. Option 8A (superclass and separate subclass tables) also handles overlapping naturally.

Let's see how this might be mapped using Option 8D.

---
<div class="page-break"></div>

### Mapping Figure 4.5 using option 8D with Boolean type fields Mflag and Pflag.

This slide, labeled (d), shows how the overlapping specialization from **Figure 4.5 (the `PART` entity) is mapped using Option 8D: Single relation with multiple type attributes.**
We use Boolean type fields, which the slide calls `Mflag` (for Manufactured) and `Pflag` (for Purchased).

*   **`PART` Relation (Single Table):**
    *   Only one table is created.
    *   Columns include:
        *   Superclass attributes: `PartNo` (Primary Key), `Description`.
        *   Attributes from `MANUFACTURED_PART` subclass: `DrawingNo`, `ManufactureDate`, `BatchNo`.
        *   Attributes from `PURCHASED_PART` subclass: `SupplierName`, `ListPrice`.
        *   The multiple Boolean type attributes:
            *   `Mflag`: This would be True if the part is a manufactured part, False otherwise.
            *   `Pflag`: This would be True if the part is a purchased part, False otherwise.

*   **How it works for an overlapping specialization:**
    *   If a part is **only manufactured**: `Mflag` = True, `Pflag` = False. The purchased-specific attributes (`SupplierName`, `ListPrice`) would be NULL.
    *   If a part is **only purchased**: `Mflag` = False, `Pflag` = True. The manufactured-specific attributes (`DrawingNo`, `ManufactureDate`, `BatchNo`) would be NULL.
    *   If a part is **both manufactured AND purchased** (the overlapping case): `Mflag` = True, `Pflag` = True. *All* attributes (both manufactured-specific and purchased-specific) could potentially have values for this part.
    *   If a part is neither (e.g., just a generic part if the specialization was partial, though this diagram implies total into at least one or it's just a base part): `Mflag` = False, `Pflag` = False, and all subclass-specific attributes would be NULL.

*   **Pros and Cons:**
    *   **Pro:** Handles overlapping specializations well within a single table. Avoids joins if you need attributes from both the superclass and potentially multiple subclasses a part belongs to.
    *   **Con:** Still has the issue of potential NULL values for attributes of subclasses that a particular part doesn't belong to. For instance, if a part is only manufactured, `SupplierName` and `ListPrice` will be NULL.

This option is a good choice for a single-table representation when dealing with overlapping subclasses. The Boolean flags clearly indicate membership in each subclass.

---
<div class="page-break"></div>

### Different Options for Mapping Generalization Hierarchies - Summary Introduction

This slide serves as an introduction to a summary figure on the *next* slide (Figure 9.5). It recaps the examples we've just walked through, which illustrate the different options for mapping specialization or generalization hierarchies.

*   The **Next Slide will show Figure 9.5**, which summarizes these mapping options visually.
    *   **(a) Mapping the EER schema in Figure 4.4 using option 8A.** This was the `EMPLOYEE` specialization (`SECRETARY`, `TECHNICIAN`, `ENGINEER`) mapped to a superclass table and separate subclass tables.
    *   **(b) Mapping the EER schema in Figure 4.3(b) using option 8B.** This was the `VEHICLE` generalization (`CAR`, `TRUCK`) mapped to only subclass tables, with superclass attributes repeated.
    *   **(c) Mapping the EER schema in Figure 4.4 using option 8C.** The `EMPLOYEE` specialization again, but this time mapped to a single table with one type attribute (`JobType`) and all subclass attributes (leading to nulls).
    *   **(d) Mapping Figure 4.5 using option 8D.** This was the overlapping `PART` specialization (`MANUFACTURED_PART`, `PURCHASED_PART`) mapped to a single table with Boolean type fields (`Mflag`, `Pflag`).

So, the upcoming Figure 9.5 will consolidate these examples into one view, making it easier to compare the resulting relational schemas for each option.

---
<div class="page-break"></div>

### Fig. 9.5: Different Options for Mapping Generalization Hierarchies - summary

Alright, here is **Figure 9.5**, which provides a visual summary of the different mapping options for generalization/specialization hierarchies that we've just discussed.

*   **(a) EMPLOYEE Specialization using Option 8A (Superclass and Subclass tables):**
    *   You see the `EMPLOYEE` table with common attributes (`Ssn`, `Fname`, etc., `Job_type`).
    *   And separate tables for `SECRETARY` (with `Ssn`, `Typing_speed`), `TECHNICIAN` (with `Ssn`, `Tgrade`), and `ENGINEER` (with `Ssn`, `Eng_type`).
    *   The `Ssn` in each subclass table is a primary key and also a foreign key referencing the `EMPLOYEE` table. Arrows indicate this link.

*   **(b) VEHICLE Generalization using Option 8B (Subclass tables only):**
    *   You see a `CAR` table with all car attributes, including those inherited from `VEHICLE` (`Vehicle_id`, `License_plate_no`, `Price`) and car-specific ones (`Max_speed`, `No_of_passengers`). `Vehicle_id` is the PK.
    *   Similarly, a `TRUCK` table with all truck attributes (`Vehicle_id` (PK), `License_plate_no`, `Price`, and truck-specific `No_of_axles`, `Tonnage`).
    *   There's no separate `VEHICLE` table here.

*   **(c) EMPLOYEE Specialization using Option 8C (Single table with one type attribute):**
    *   You see a single `EMPLOYEE` table.
    *   It contains all common attributes (`Ssn`, `Fname`, etc.), the type attribute `Job_type`, AND all specific attributes from all subclasses (`Typing_speed`, `Tgrade`, `Eng_type`).
    *   As discussed, this leads to NULLs for attributes not relevant to a given `Job_type`.

*   **(d) PART Specialization using Option 8D (Single table with multiple type attributes):**
    *   You see a single `PART` table.
    *   It contains common attributes (`Part_no`, `Description`), the Boolean flags `Mflag` and `Pflag`, AND all specific attributes from both subclasses (`Drawing_no`, `Manufacture_date`, `Batch_no` from manufactured, and `Supplier_name`, `List_price` from purchased).
    *   This accommodates overlapping parts, but again, with potential NULLs for non-applicable subclass attributes.

This figure is a really good side-by-side comparison. It highlights how the same conceptual structure (like the `EMPLOYEE` specialization) can result in very different relational schemas depending on the mapping option chosen. The choice, as always, depends on the specific requirements, data characteristics, and query patterns.

---
<div class="page-break"></div>



## Mapping EER Model Constructs to Relations (contd.)

We've covered the basic options for specialization and generalization. Now, let's consider a more complex scenario within EER models: shared subclasses, which involve multiple inheritance.

### ■ Mapping of Shared Subclasses (Multiple Inheritance)

*   A **shared subclass**, like `STUDENT_ASSISTANT` in a university database (which we'll see in an upcoming figure), is a subclass of *several* superclasses. This indicates **multiple inheritance** – the `STUDENT_ASSISTANT` inherits attributes and relationships from all its parent superclasses.
    *   A key constraint here is that for this to be modeled as a shared subclass (rather than a category, which we'll discuss later), **these parent superclasses must all have the same key attribute**. If they had different primary keys, it would be much harder to uniquely identify an instance of the shared subclass using a single key inherited consistently. If the keys are different, it's usually modeled as a category.

*   How do we map these? The good news is that **we can apply any of the options discussed in Step 8 (8A, 8B, 8C, 8D) to a shared subclass**. However, we need to be mindful of the "restriction discussed in Step 8," which usually refers to ensuring the primary key mechanism works correctly and consistently.
    *   The slide mentions that in the example that follows (Figure 4.7 and its mapping in Figure 9.6), **both Option 8C and 8D principles are used for mapping the shared class `STUDENT_ASSISTANT`**. This means it will likely be part of a larger single table structure, possibly with type flags or a role attribute.

Multiple inheritance adds complexity, but our existing mapping strategies can be adapted. The main challenge is managing the attributes and keys from multiple superclasses.

Let's look at the example diagram.

---
<div class="page-break"></div>

### FIGURE 4.7 A specialization lattice with multiple inheritance for a UNIVERSITY database.

Here is **Figure 4.7**, which shows a **specialization lattice** for a UNIVERSITY database. A lattice can occur when you have multiple inheritance.

Let's trace the hierarchy:

*   At the top, we have a general superclass `PERSON` with attributes `SSN` (key), `Name`, `Sex`, `Address`, `BirthDate`.
*   `PERSON` is specialized (disjoint, indicated by 'd' and the arcs) into:
    *   `EMPLOYEE`: with an additional attribute `Salary`.
    *   `ALUMNUS`: with a multivalued attribute `Degrees` (composite: `Year`, `Degree`, `Major`).
    *   `STUDENT`: with an additional attribute `MajorDept`.

Now, things get more interesting:
*   `EMPLOYEE` is further specialized (disjointly) into:
    *   `STAFF`: with attribute `Position`.
    *   `FACULTY`: with attribute `Rank`.
    *   And here's the key: `STUDENT_ASSISTANT`.

*   `STUDENT` is further specialized (disjointly) into:
    *   `GRADUATE_STUDENT`: with attribute `DegreeProgram`.
    *   `UNDERGRADUATE_STUDENT`: with attribute `Class`.
    *   And again, `STUDENT_ASSISTANT`.

So, `STUDENT_ASSISTANT` is a subclass of *both* `EMPLOYEE` *and* `STUDENT`. This is multiple inheritance. A student assistant is both an employee (gets a salary, has employee characteristics) and a student (is enrolled, has student characteristics). It inherits attributes from `PERSON`, `EMPLOYEE`, and `STUDENT`.
*   The `STUDENT_ASSISTANT` itself has an attribute `PercentTime`.
*   `STUDENT_ASSISTANT` can be further specialized (disjointly) into `RESEARCH_ASSISTANT` (with attribute `Project`) and `TEACHING_ASSISTANT` (with attribute `Course`).

This lattice structure clearly shows the shared `STUDENT_ASSISTANT` subclass. Mapping this requires careful consideration of how to consolidate attributes from its multiple parents. Since both `EMPLOYEE` and `STUDENT` ultimately inherit `SSN` from `PERSON`, they share the same key, which is essential for modeling `STUDENT_ASSISTANT` this way.

---
<div class="page-break"></div>

### FIGURE 9.6 Mapping the EER specialization lattice in Figure 4.7 using multiple options.

Now, let's look at **Figure 9.6**, which shows one way to map the complex EER specialization lattice from Figure 4.7 (the UNIVERSITY database) into relational tables, using a combination of mapping options.

*   **`PERSON` Relation:**
    *   Columns: `Ssn` (PK), `Name`, `Birth_date`, `Sex`, `Address`.
    *   This is a straightforward mapping of the top-level superclass (Option 8A style).

*   **`EMPLOYEE` Relation:**
    *   Columns: `Ssn` (PK, FK to `PERSON`), `Salary`, `Employee_type` (this acts like a type attribute from Option 8C to distinguish `STAFF`, `FACULTY`, `STUDENT_ASSISTANT` within employees), `Position` (for STAFF), `Rank` (for FACULTY), `Percent_time` (for STUDENT_ASSISTANT), `Ra_flag` (Boolean for RESEARCH_ASSISTANT - Option 8D), `Ta_flag` (Boolean for TEACHING_ASSISTANT - Option 8D), `Project` (for RESEARCH_ASSISTANT), `Course` (for TEACHING_ASSISTANT).
    *   This table is quite complex. It seems to be using a mix:
        *   It acts as the superclass table for employees (like Option 8A for `PERSON`-`EMPLOYEE`).
        *   But then it tries to incorporate its own subclasses (`STAFF`, `FACULTY`, `STUDENT_ASSISTANT`, and even `RESEARCH_ASSISTANT`, `TEACHING_ASSISTANT`) using a single-table strategy (like Option 8C/8D), leading to many attributes and potential NULLs. `Employee_type` could differentiate staff/faculty/student_assistant. `Ra_flag` and `Ta_flag` then further specialize student assistants.
        *   This is a very condensed way to map the employee branch.

*   **`ALUMNUS` Relation:**
    *   Columns: `Ssn` (PK, FK to `PERSON`).
    *   This table itself is simple (Option 8A style for `PERSON`-`ALUMNUS`).

*   **`ALUMNUS_DEGREES` Relation:**
    *   Columns: `Ssn` (Part of PK, FK to `ALUMNUS`), `Year` (Part of PK), `Degree` (Part of PK), `Major`.
    *   This handles the multivalued composite attribute `Degrees` of `ALUMNUS` (Step 6 mapping).

*   **`STUDENT` Relation:**
    *   Columns: `Ssn` (PK, FK to `PERSON`), `Major_dept`, `Grad_flag` (Boolean for `GRADUATE_STUDENT` - Option 8D), `Undergrad_flag` (Boolean for `UNDERGRADUATE_STUDENT` - Option 8D), `Degree_program` (for `GRADUATE_STUDENT`), `Class` (for `UNDERGRADUATE_STUDENT`), `Student_assist_flag` (Boolean for `STUDENT_ASSISTANT` - Option 8D).
    *   Similar to the `EMPLOYEE` table, this `STUDENT` table uses a mixed approach. It's the superclass for students, but also uses Boolean flags (Option 8D) to incorporate its subclasses, including its role as a parent to `STUDENT_ASSISTANT`.

*   **Handling `STUDENT_ASSISTANT` (the shared subclass):**
    *   Information about `STUDENT_ASSISTANT` seems to be split or duplicated:
        *   In the `EMPLOYEE` table: `Employee_type` might indicate 'StudentAssistant', and attributes like `Percent_time`, `Ra_flag`, `Ta_flag`, `Project`, `Course` are present.
        *   In the `STUDENT` table: `Student_assist_flag` indicates if a student is also an assistant.
    *   To get *all* information for a `STUDENT_ASSISTANT`, one would likely need to join `PERSON`, `EMPLOYEE`, and `STUDENT` tables on `Ssn` where the relevant flags/types are set.

This mapping is an example of how designers might choose to combine strategies. The `EMPLOYEE` and `STUDENT` tables become quite wide and prone to nulls to accommodate their respective specializations using a single-table approach for those branches. The shared nature of `STUDENT_ASSISTANT` is handled by having relevant flags/attributes in both its parent-lineage tables (`EMPLOYEE` and `STUDENT`). Querying `STUDENT_ASSISTANT` would require care.

This shows the flexibility but also the potential complexity when mapping rich EER diagrams.

---
<div class="page-break"></div>

## Mapping EER Model Constructs to Relations (contd.)

We now come to the final step in our EER mapping algorithm, Step 9, which deals with a construct called Union Types, also known as Categories.

### Step 9: Mapping of Union Types (Categories).

*   A **category** or **union type** represents a collection of entities that is a *subset of the union* of several distinct entity types. A key characteristic is that the superclasses defining the category might have **different keys**. This is a major difference from shared subclasses (multiple inheritance) where superclasses typically share the same key.
    *   Because the defining superclasses can have different keys, it's customary to **specify a new key attribute, called a `surrogate key`**, when creating a relation to correspond to the category. This surrogate key provides a single, uniform primary key for the category relation itself.

*   **Example from the slide (referring to Figure 4.8, which we'll see next):**
    *   Suppose we have an `OWNER` category in our EER diagram. An owner could be a `PERSON`, a `BANK`, or a `COMPANY`. These three entity types likely have different primary keys (`SSN` for `PERSON`, `BName` for `BANK`, `CName` for `COMPANY`).
    *   To map this `OWNER` category, we would:
        *   Create a new relation called `OWNER`.
        *   This `OWNER` table would include any attributes that are specific to the `OWNER` category itself (if any).
        *   The **primary key of this `OWNER` relation will be the new surrogate key**. The slide suggests calling it `OwnerId`.
        *   We would also need a way to link this `OwnerId` back to the original `PERSON`, `BANK`, or `COMPANY` entity that this particular owner instance represents. This often involves additional foreign keys in the source tables (PERSON, BANK, COMPANY) pointing to this `OwnerId`, or foreign keys in the OWNER table that conditionally point back (which is more complex due to different target tables). Often, the `OWNER` table might also include a "type" attribute to indicate if the owner is a Person, Bank, or Company, and then a nullable foreign key for each possible source type.

Categories are powerful for modeling entities whose members can come from diverse underlying types. The surrogate key is crucial for giving the category its own distinct identity in the relational model.

Let's look at the EER diagram for this.

---
<div class="page-break"></div>

### FIGURE 4.8 Two categories (union types): OWNER and REGISTERED_VEHICLE.

Here's **Figure 4.8**, illustrating two categories (union types): `OWNER` and `REGISTERED_VEHICLE`.

*   **`OWNER` Category:**
    *   The entities `PERSON` (keyed by `SSN`), `BANK` (keyed by `BName`), and `COMPANY` (keyed by `CName`) are shown.
    *   A circle with a 'U' inside represents the union operation. These three entity types unite to form the `OWNER` category.
    *   This means an `OWNER` can be *either* a `PERSON`, *or* a `BANK`, *or* a `COMPANY`.
    *   The `OWNER` category participates in an `OWNS` relationship (M:N) with `REGISTERED_VEHICLE`. The `OWNS` relationship has attributes `LienOrRegular` and `PurchaseDate`.

*   **`REGISTERED_VEHICLE` Category:**
    *   Similarly, `CAR` (with attributes like `CMake`, `CModel`, `CStyle`, `CYear`, `VehicleId`) and `TRUCK` (with attributes like `TMake`, `TModel`, `Tonnage`, `TYear`, `VehicleId`) unite to form the `REGISTERED_VEHICLE` category.
    *   Notice `CAR` and `TRUCK` might share a common key `VehicleId` in this depiction, or `VehicleId` might be distinct within cars and distinct within trucks but not globally unique across both without further context. If their keys were different, a surrogate key for `REGISTERED_VEHICLE` would be essential. If `VehicleId` *is* globally unique (e.g., from a `VEHICLE` superclass not explicitly shown as parent to CAR/TRUCK here but implied by them both having `VehicleId`), then `VehicleId` could potentially serve as the key for `REGISTERED_VEHICLE`. However, the general approach for categories is to introduce a surrogate key if there's any doubt or if the defining classes truly have disparate keys.
    *   `REGISTERED_VEHICLE` has an attribute `LicensePlateNo`.

This diagram shows how categories allow us to group entities from different sources that share a common role or participation in a relationship. The key challenge in mapping is handling the potentially different primary keys of the source entities.

---
<div class="page-break"></div>

### FIGURE 9.7 Mapping the EER categories (union types) in Figure 4.8 to relations.

Now, let's look at **Figure 9.7**, which shows how the EER categories from Figure 4.8 (`OWNER` and `REGISTERED_VEHICLE`) are mapped to relations. This illustrates Step 9.

*   **Mapping the `OWNER` Category:**
    *   **`PERSON` Relation:**
        *   Columns: `Ssn` (PK), `Driver_license_no`, `Name`, `Address`, and importantly, `Owner_id` (FK).
    *   **`BANK` Relation:**
        *   Columns: `Bname` (PK), `Baddress`, and `Owner_id` (FK).
    *   **`COMPANY` Relation:**
        *   Columns: `Cname` (PK), `Caddress`, and `Owner_id` (FK).
    *   **`OWNER` Relation (for the category):**
        *   Column: `Owner_id` (PK). This is the **surrogate key** for the `OWNER` category.
        *   This table might also have a type attribute (e.g., `OwnerType` indicating 'Person', 'Bank', 'Company'), though not explicitly shown here. The foreign keys in `PERSON`, `BANK`, `COMPANY` pointing to `OWNER.Owner_id` establish the link. An `Owner_id` is generated for each actual owner, and the corresponding source table (Person, Bank, or Company) gets that `Owner_id`.

*   **Mapping the `REGISTERED_VEHICLE` Category:**
    *   The diagram shows tables for `CAR` and `TRUCK` which would have their own attributes.
    *   **`REGISTERED_VEHICLE` Relation (for the category):**
        *   Columns: `Vehicle_id` (PK), `License_plate_number`.
        *   In this specific mapping, it seems `Vehicle_id` is assumed to be a common, unique key across `CAR` and `TRUCK` (perhaps they are subclasses of an unshown `VEHICLE` superclass). If `CAR` and `TRUCK` had truly different keys, `REGISTERED_VEHICLE` would need its own surrogate key, and `CAR` and `TRUCK` would get foreign keys pointing to it, similar to the `OWNER` mapping.
        *   The `CAR` and `TRUCK` tables would also have `Vehicle_id` as their primary key (and foreign key to `REGISTERED_VEHICLE` if a separate surrogate key was used for the category).
        *   The diagram implies `REGISTERED_VEHICLE.Vehicle_id` is the primary key, and `CAR.Vehicle_id` and `TRUCK.Vehicle_id` are foreign keys to it.

*   **Mapping the `OWNS` Relationship:**
    *   **`OWNS` Relation:**
        *   This is an M:N relationship between `OWNER` and `REGISTERED_VEHICLE`.
        *   Columns: `Owner_id` (Part of PK, FK to `OWNER.Owner_id`), `Vehicle_id` (Part of PK, FK to `REGISTERED_VEHICLE.Vehicle_id`), `Purchase_date`, `Lien_or_regular`.
        *   This correctly maps the M:N relationship using the (surrogate) keys of the participating categories.

This mapping illustrates the use of surrogate keys (`Owner_id`) for categories where base entities have different keys. For `REGISTERED_VEHICLE`, the mapping shown assumes a common key `Vehicle_id` can be used, simplifying it slightly compared to the `OWNER` category's mapping. The key takeaway is the introduction of a new relation for the category, often with a surrogate key.

---
<div class="page-break"></div>

## Mapping Exercise-1

Alright, we've covered all the steps of ER and EER to relational mapping. Now for a couple of exercises to put this into practice.

**Exercise 9.4: Map this schema into a set of relations.**

The slide displays **Figure 9.8, an ER schema for a SHIP_TRACKING database.** Let's analyze this ER diagram:

*   **Entities:**
    *   `SHIP`: Attributes `SName` (key), `Owner`.
    *   `SHIP_MOVEMENT`: Attributes `Timestamp` (composite: `Date`, `Time`), `Latitude`, `Longitude`. This seems to be related to `SHIP` via `HISTORY`.
    *   `PORT`: Attribute `PName` (key).
    *   `SHIP_TYPE`: Attributes `Type` (key), `Tonnage`, `Hull`.
    *   `STATE/COUNTRY`: Attribute `Name` (key), `Continent`.
    *   `SEA/OCEAN/LAKE`: Attribute `Name` (key).

*   **Relationships:**
    *   `HISTORY`: Between `SHIP` (1) and `SHIP_MOVEMENT` (N). This looks like `SHIP_MOVEMENT` might be a weak entity or highly dependent on `SHIP`, recording historical positions.
    *   `TYPE`: Between `SHIP` (N) and `SHIP_TYPE` (1). A ship has one type; a type can apply to many ships.
    *   `HOME_PORT`: Between `SHIP` (N) and `PORT` (1). A ship has one home port; a port can be home to many ships.
    *   `VISITS`: An M:N relationship between `SHIP` and `PORT`. A ship visits many ports; a port is visited by many ships. It has attributes `StartDate` and `EndDate`. The cardinalities (0,*) on SHIP side and (1,1) on PORT side (for a specific visit instance) are shown. This M:N relationship itself is also shown as an entity diamond, which is common.
    *   `IN`: Between `PORT` (N) and `STATE/COUNTRY` (1). A port is in one state/country.
    *   `ON`: Between `PORT` (N) and `SEA/OCEAN/LAKE` (1). A port is on one sea/ocean/lake.

Your task for this exercise would be to go through our 9 steps and define the set of relational tables, their columns, primary keys, and foreign keys that would result from this ER diagram. Think about strong entities, weak entities (if any), 1:N relationships, M:N relationships, and attributes of relationships.

---
<div class="page-break"></div>

## Mapping Exercise-2

Here's another exercise.

**Exercise 9.9: Map this schema into a set of relations.**

The slide displays **Figure 9.9, an EER diagram for a car dealer.** Let's examine it:

*   **Entities/Superclasses/Subclasses:**
    *   `VEHICLE`: Superclass with attributes `Vin` (key), `Price`, `Model`, `Date` (perhaps date of acquisition or sale).
    *   `VEHICLE` is specialized (disjoint, 'd') into:
        *   `CAR`: Subclass with attribute `Engine_size`.
        *   `TRUCK`: Subclass with attribute `Tonnage`.
        *   `SUV`: Subclass with attribute `No_seats`.

*   **Other Entities:**
    *   `SALESPERSON`: Attributes `Sid` (key), `Name`.
    *   `CUSTOMER`: Attributes `Ssn` (key), `Name`, `Address` (composite: `Street`, `City`, `State`).

*   **Relationships:**
    *   `SALE`: This is a ternary-like relationship (though drawn connecting `VEHICLE`, `SALESPERSON`, and `CUSTOMER`). It connects one `VEHICLE` (N-side from `VEHICLE` to `SALE` entity, implying a vehicle might be involved in multiple sale attempts or records, or this is a 1-side if a vehicle is sold once), one `SALESPERSON` (1-side to `SALE`), and one `CUSTOMER` (1-side to `SALE`). The `SALE` event itself might have the `Date` attribute (or `Date` might be on `VEHICLE` as date of sale). The cardinalities here are N from `VEHICLE` to `SALE`, and 1 from `SALESPERSON` to `SALE`, and 1 from `CUSTOMER` to `SALE`. This is an interesting relationship. It seems to represent the event of a sale. If `Date` is an attribute of the `SALE` itself, then `SALE` would be a relationship entity.

Your task here is to map this EER diagram. You'll need to:
1.  Decide how to map the `VEHICLE` specialization (`CAR`, `TRUCK`, `SUV`) using one of the options (8A, 8B, 8C, or 8D). Consider if it's total/partial.
2.  Map the regular entities `SALESPERSON` and `CUSTOMER`.
3.  Determine how to map the `SALE` relationship. Given its connections and cardinalities, it will likely become its own table linking `VEHICLE`, `SALESPERSON`, and `CUSTOMER`, and possibly holding the `Date` attribute.

Think about the primary and foreign keys for all resulting tables.

---
<div class="page-break"></div>

## Chapter Summary

So, to wrap up Chapter 9, let's quickly review what we've covered. This chapter was all about the crucial process of transforming our conceptual ER and EER diagrams into a concrete relational database schema.

*   We started with the **ER-to-Relational Mapping Algorithm**, a systematic 7-step process:
    *   **Step 1:** Mapping of Regular (Strong) Entity Types into tables.
    *   **Step 2:** Mapping of Weak Entity Types, including the primary key from the owner entity.
    *   **Step 3:** Mapping of Binary 1:1 Relation Types, with options like foreign key, merging, or a separate relationship table.
    *   **Step 4:** Mapping of Binary 1:N Relationship Types, typically by placing a foreign key on the N-side.
    *   **Step 5:** Mapping of Binary M:N Relationship Types, which always results in a new junction/relationship table.
    *   **Step 6:** Mapping of Multivalued attributes, requiring a new table to hold the multiple values.
    *   **Step 7:** Mapping of N-ary Relationship Types (ternary, etc.), also resulting in a new relationship table.

*   Then we moved on to **Mapping EER Model Constructs to Relations**, focusing on more advanced concepts:
    *   **Step 8:** Options for Mapping Specialization or Generalization. We explored four main options (8A, 8B, 8C, 8D), each with its own trade-offs regarding number of tables, null values, and redundancy, depending on whether it's a superclass/subclass split, subclass-only, or single-table approach.
    *   **Step 9:** Mapping of Union Types (Categories), where entities from different superclasses (potentially with different keys) form a new category, often requiring a surrogate key for the category's relation.

Understanding these mapping algorithms and options is fundamental for any database designer. It's the bridge between abstract modeling and practical database implementation. The choices made during this mapping process significantly impact the database's structure, performance, and integrity.

That concludes our discussion of Chapter 9. Make sure to review these steps and practice with the exercises, as this is a very practical and important skill.

---
<div class="page-break"></div>