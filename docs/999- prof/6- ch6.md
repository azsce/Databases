---
title: "6. chapter 6"
---

# Basic SQL
Alright, class, welcome back. Today, we're diving into a very practical and foundational topic: **Basic SQL**. SQL, or Structured Query Language, is the standard language for interacting with relational databases. Mastering the basics here will empower you to define, query, and manipulate data effectively.

# CHAPTER 6: Basic SQL

So, we're officially in Chapter 6, focusing entirely on "Basic SQL." This chapter is crucial because SQL is the lingua franca of relational databases. Whether you become a database administrator, a software developer, or a data analyst, proficiency in SQL is an indispensable skill. We'll start from the ground up, ensuring everyone builds a solid understanding.

---
<div class="page-break"></div>

## Chapter 6 Outline

Let's briefly look at the road map for this chapter. What specific areas of Basic SQL will we cover?

*   First, we'll delve into **SQL Data Definition and Data Types**. This is about how we define the structure of our database tables and the types of data each column can hold.
*   Next, we'll explore **Specifying Constraints in SQL**. Constraints are rules that ensure data integrity and accuracy.
*   Then, we'll get to the exciting part: **Basic Retrieval Queries in SQL**. This is how we ask questions of our database and get information out.
*   We'll also cover the essential commands for modifying data: **INSERT, DELETE, and UPDATE Statements in SQL**.
*   And finally, we'll touch upon some **Additional Features of SQL**, giving you a glimpse of more advanced capabilities you'll encounter later.

A good, solid agenda. Let's begin with the fundamentals of SQL itself.

---
<div class="page-break"></div>

## Basic SQL

So, let's talk about SQL in a bit more detail.

*   The **SQL language** itself is widely considered one of the major reasons for the commercial success and widespread adoption of relational databases. Its relatively straightforward, English-like syntax made database interaction accessible to a broader audience than previous, more programmatic interfaces.

*   Now, regarding **SQL's origins**:
    *   It's interesting to note that the conceptual foundation of SQL lies in what's called relational predicate calculus, specifically tuple calculus, which we'll touch upon in Chapter 8. The very first language proposed based on these ideas was named SQUARE, which stood for "Specifying Queries as Relational Expressions."
    *   SQL, as we know it, actually evolved from a project at IBM and was originally called "SEQUEL," an acronym for "Structured English Query Language." This name clearly reflected its design goal: to be a query language that felt somewhat natural, like structured English. The paper that introduced it was aptly titled "SEQUEL TO SQUARE," showing its lineage. An interesting bit of trivia: IBM couldn't copyright the term "SEQUEL," so they shortened it to SQL, and that's the term they copyrighted.
    *   Today, while some old-timers might still pronounce it "sequel," it's popularly known and referred to as "Structured Query Language," or S.Q.L.

---
<div class="page-break"></div>

## SQL Data Definition, Data Types, Standards

When we start working with SQL, it's important to get the terminology straight and understand the breadth of its capabilities.

*   **Terminology:**
    *   You'll often hear the terms `Table`, `row`, and `column` used in the context of SQL. These correspond directly to the relational model terms we've learned: `relation` (for table), `tuple` (for row), and `attribute` (for column). So, when we talk about an SQL table, we're really talking about a relation.
    *   SQL is a comprehensive language. It's not just for querying. It has features for:
        *   **Data Definition (DDL):** Creating and modifying the structure of the database.
        *   **Data Manipulation (DML):** Retrieving, inserting, deleting, and updating data.
        *   **Transaction Control:** Managing sequences of operations to ensure consistency, for example, using Transact-SQL, which we'll see in Chapter 20.
        *   **Indexing (Chapter 17):** Creating indexes to speed up queries.
        *   **Security Specification (Chapter 30):** Using commands like `GRANT` and `REVOKE` to manage user permissions.
        *   **Active Databases (Chapter 26):** Defining triggers that automatically execute in response to certain events.
        *   And it also supports working with **Multi-media data (Chapter 26)** and **Distributed Databases (Chapter 23)**, among other things. It's a very powerful and versatile language.

*   The primary command for data definition, for creating the structures in our database, is the **`CREATE` statement**. We'll be seeing a lot of this.

---
<div class="page-break"></div>

## Schema and Catalog Concepts in SQL

Alright, let's discuss how SQL organizes database objects using schemas and catalogs. It's important to note that there can be some variations in how these concepts are implemented across different commercial Relational Database Management Systems (RDBMS), but the SQL standard provides a general framework.

*   An **`SQL schema`** is essentially a named collection of database objects.
    *   It's identified by a unique **`schema name`**. Think of it as a container or a namespace.
    *   A schema also includes an **`authorization identifier`**, which typically specifies the user or role that owns the schema and its objects. It also contains **`descriptors`** for every element within that schema – that is, the definitions of tables, constraints, views, and so on.
*   So, what are these **`schema elements`**? They include:
    *   **Tables:** The fundamental structures for storing data.
    *   **Constraints:** Rules that ensure data integrity.
    *   **Views:** Virtual tables based on the results of stored queries.
    *   **Domains:** User-defined data types.
    *   And various other constructs that help organize and manage the database.
*   A small but crucial syntactic rule: **Each statement in SQL typically ends with a semicolon (;)**. This tells the RDBMS that the statement is complete.

---

### Schema and Catalog Concepts in SQL (cont'd.)

Continuing with schemas and catalogs:

*   To explicitly create a schema, we use the **`CREATE SCHEMA` statement**.
    *   For example, the command `CREATE SCHEMA COMPANY AUTHORIZATION 'Jsmith';` would create a new schema named 'COMPANY' and assign its ownership or authorization to the user 'Jsmith'. Any tables or other objects created within this schema would then be associated with 'COMPANY'.

*   Now, what about a **`Catalog`**?
    *   A catalog is a **named collection of schemas** within an SQL environment. So, a catalog can contain multiple schemas, and each schema can contain multiple tables, views, etc. This provides another level of organization, especially in large, complex database environments where you might have schemas for different departments or applications.
    *   The SQL standard also defines the concept of a **cluster of catalogs**, though this level of organization is less commonly encountered in typical day-to-day use for smaller systems. It allows for grouping multiple catalogs, perhaps managed by different RDBMS instances.

The hierarchy generally looks like this: A database server might manage a cluster of catalogs (though often just one primary catalog is in focus). Within a catalog, you have multiple schemas. And within each schema, you have your tables, views, and other database objects.

---
<div class="page-break"></div>

## The CREATE TABLE Command in SQL

One of the most fundamental Data Definition Language, or DDL, commands in SQL is `CREATE TABLE`. This is how we define the structure of our relations, or tables.

*   When **specifying a new relation** (or table), you need to:
    *   First, **provide the name of the table**. This name should be unique within its schema.
    *   Second, you must **specify its attributes (or columns), their data types, and any initial constraints** that apply to those attributes. For example, you'd specify if a column must contain a value (NOT NULL), or if it's a primary key.

*   You **can optionally specify the schema** to which the new table belongs:
    *   For instance, `CREATE TABLE COMPANY.EMPLOYEE ...` explicitly creates the `EMPLOYEE` table within the `COMPANY` schema.
    *   If you omit the schema name, like `CREATE TABLE EMPLOYEE ...`, the table is typically created in a default schema associated with the current user or session, depending on the RDBMS. The specifics can vary, but it's often good practice to be explicit, especially in larger projects.

---

### The CREATE TABLE Command in SQL (cont'd.)

When we talk about tables created with `CREATE TABLE`, it's useful to distinguish between two types:

*   **`Base tables`** (also known as base relations):
    *   These are the "real" tables. When you define a base table, the **relation and its tuples (rows) are actually created and physically stored** as a file or a set of files by the DBMS. This is where the actual data resides.

*   **`Virtual relations`** (more commonly known as **`views`**):
    *   Views are quite different. They are **created through the `CREATE VIEW` statement**, not `CREATE TABLE`.
    *   Crucially, views **do not correspond to any physical file** where their data is stored directly. Instead, a view is essentially a stored query. When you query a view, the DBMS executes the underlying query against the base tables and presents the results as if they came from a real table. Views are powerful for simplifying complex queries, providing customized perspectives on data, and for security purposes. We'll discuss views in more detail later.

For now, our primary focus in creating database structures will be on defining these base tables.

---
<div class="page-break"></div>

## COMPANY relational database schema (Fig. 5.7)

Now, let's look at Figure 5.7. This diagram visually represents the **COMPANY relational database schema** that we'll be using as a running example throughout many of our discussions, including our SQL examples.

You can see several rectangles, each representing a table, or relation.
*   At the top, we have the `EMPLOYEE` table. Its attributes include `Fname` (first name), `Minit` (middle initial), `Lname` (last name), `Ssn` (social security number – which is underlined, indicating it's the primary key), `Bdate` (birth date), `Address`, `Sex`, `Salary`, `Super_ssn` (supervisor's SSN, which will be a foreign key referencing `Ssn` in the same table), and `Dno` (department number, a foreign key to the `DEPARTMENT` table).

*   Then there's the `DEPARTMENT` table with attributes like `Dname` (department name), `Dnumber` (department number – the primary key here), `Mgr_ssn` (manager's SSN, a foreign key to `EMPLOYEE`), and `Mgr_start_date`.

*   We also see `DEPT_LOCATIONS`. This table stores the multiple locations a department might have. It has `Dnumber` and `Dlocation`. Together, these form a composite primary key, and `Dnumber` is also a foreign key to `DEPARTMENT`.

*   The `PROJECT` table includes `Pname` (project name), `Pnumber` (project number – the primary key), `Plocation`, and `Dnum` (department number controlling the project, a foreign key to `DEPARTMENT`).

*   The `WORKS_ON` table is an associative entity or a relationship table. It links employees to projects and records the `Hours` an employee (`Essn` – employee's SSN) works on a particular project (`Pno` – project number). `Essn` and `Pno` together form the primary key, and individually, they are foreign keys to `EMPLOYEE` and `PROJECT`, respectively.

*   Finally, the `DEPENDENT` table stores information about employee dependents. It has `Essn` (linking to the employee), `Dependent_name`, `Sex`, `Bdate`, and `Relationship` (e.g., spouse, son, daughter). `Essn` and `Dependent_name` form the primary key here.

The arrows in such diagrams typically indicate foreign key relationships. For example, an arrow from `Dno` in `EMPLOYEE` to `Dnumber` in `DEPARTMENT` signifies that `Dno` in `EMPLOYEE` refers to a valid department number in the `DEPARTMENT` table. Understanding this schema is key to understanding the SQL queries we'll be writing.

---
<div class="page-break"></div>

## One possible database state for the COMPANY relational database schema (Fig. 5.6)

Now that we've seen the *structure* or *schema* of the COMPANY database, let's look at Figure 5.6, which shows **one possible database state**. A `database state` or `snapshot` refers to the actual data residing in the database at a particular point in time. While the schema defines the blueprint, the state is the content.

Let's examine the data in some of these tables.

First, the **`EMPLOYEE` table**:
The columns are: `Fname` (First Name), `Minit` (Middle Initial), `Lname` (Last Name), `Ssn` (which is the Social Security Number column, serving as a unique identifier for each employee), `Bdate` (Birthdate), `Address`, `Sex`, `Salary`, `Super_ssn` (Supervisor's SSN), and `Dno` (Department Number).

Let's take the first row as an example to understand how data populates these columns:
We have an employee named John B. Smith. This employee has an associated Social Security Number. His birthdate is listed as January 9th, 1965. His address is 731 Fondren, Houston, TX. He is identified as Male, earns a salary of $30,000. The `Super_ssn` column indicates his supervisor's unique identifier, and he works in department number 5.

This is how each row in the `EMPLOYEE` table represents a specific employee and their attributes.

Next, let's look at the **`DEPARTMENT` table**:
Its columns are `Dname` (Department Name), `Dnumber` (Department Number, which is the primary key), `Mgr_ssn` (Manager's SSN), and `Mgr_start_date` (the date the manager started managing the department).
For the first row: The 'Research' department has a department number of 5. It has a manager, identified by their SSN, who started on May 22nd, 1988.

And the **`DEPT_LOCATIONS` table**:
This table shows department numbers and their corresponding locations. For instance, department number 1 is located in 'Houston'. Department number 5, interestingly, has multiple locations listed: 'Bellaire', 'Sugarland', and also 'Houston'. This illustrates a one-to-many relationship where one department can have several office locations.

This figure, showing the actual data, helps us visualize how the schema we defined earlier gets populated in a real-world scenario. We'll continue to refer to this sample data as we construct our SQL queries.

---

### One possible database state for the COMPANY relational database schema - continued (Fig. 5.6)

Continuing with our look at the sample data in Figure 5.6, let's examine the remaining tables.

First, the **`WORKS_ON` table**:
This table links employees to the projects they work on and records the hours. The columns are `Essn` (Employee's SSN), `Pno` (Project Number), and `Hours`.
Looking at the first row: The employee with a specific SSN (which we saw earlier might be John Smith's) is working on project number 1 for 32.5 hours. The second row shows the same employee also working on project number 2 for 7.5 hours. This table beautifully models a many-to-many relationship between employees and projects.

Next, the **`PROJECT` table**:
This table lists the projects. The columns are `Pname` (Project Name), `Pnumber` (Project Number), `Plocation` (Project Location), and `Dnum` (the number of the department that controls the project).
For example, the first project, 'ProductX', has project number 1, is located in 'Bellaire', and is controlled by department number 5.

Finally, the **`DEPENDENT` table**:
This table stores information about the dependents of employees. The columns are `Essn` (Employee's SSN, linking the dependent to an employee), `Dependent_name`, `Sex`, `Bdate` (Birthdate of the dependent), and `Relationship` (e.g., Daughter, Son, Spouse).
The first row shows that an employee (identified by their SSN, perhaps Franklin Wong from our earlier `EMPLOYEE` table data) has a dependent named Alice, who is female, born on April 5th, 1986, and her relationship to the employee is 'Daughter'.

So, these tables, when populated, give us a complete snapshot of the company's data according to our defined schema. Keep these tables and their sample data in mind, as they will be the basis for the SQL queries we'll be writing shortly.

---
<div class="page-break"></div>

## An Example of CREATE Statement

Now, let's transition from looking at existing data to how we actually define the structure for such data using SQL. We'll start with the `CREATE TABLE` statement.

On the slide, you see an example of a `CREATE TABLE` statement specifically for the `PROJECT` table from our COMPANY schema. This statement is our blueprint for what a "project" looks like in our database.

We begin with the keywords `CREATE TABLE PROJECT`, clearly stating our intention to define a new table named `PROJECT`.

Inside the parentheses, we define each column. For instance, `Pname VARCHAR(15) NOT NULL` tells us that every project will have a name, stored as a variable-length string of up to 15 characters, and this name is mandatory – it cannot be null. Similarly, `Pnumber INT NOT NULL` defines the project number as a mandatory integer. We also define `Plocation` as a variable-length string for the project's location, but this one *can* be null, meaning a location isn't strictly required. The `Dnum INT NOT NULL` specifies the department number controlling the project, also a mandatory integer.

After defining the individual columns and their basic properties, we declare more comprehensive rules, or constraints, at the table level.
The line `PRIMARY KEY (Pnumber)` is crucial; it designates `Pnumber` as the primary key. This means every project must have a unique project number, and it implicitly ensures project numbers are not null.
`UNIQUE (Pname)` adds another rule: project names must also be unique. This makes `Pname` what we call a candidate key.
Finally, the `FOREIGN KEY (Dnum) REFERENCES DEPARTMENT(Dnumber)` clause establishes a critical link. It says that the `Dnum` in our `PROJECT` table must match an existing `Dnumber` in the `DEPARTMENT` table. This enforces referential integrity, ensuring that every project is associated with a valid, existing department. This is fundamental for maintaining data consistency across our database.

And as always in SQL, the semicolon marks the end of this complete statement. This is the standard way we define the structure and constraints of our tables.

---

<div class="page-break"></div>

## SQL CREATE TABLE data definition statements for defining the COMPANY schema from Figure 5.7 (Fig. 6.1)

Now, let's broaden our view and look at Figure 6.1, which presents the SQL Data Definition Language (DDL) statements needed to construct the entire COMPANY schema we've been referencing. This is how we'd programmatically create the database structure.

First, we see the `CREATE TABLE EMPLOYEE` statement. This defines our `EMPLOYEE` table.
We specify attributes like `Fname` (first name) and `Lname` (last name) as `VARCHAR(15) NOT NULL`, meaning they are mandatory text fields. The `Ssn` (Social Security Number) is defined as `CHAR(9) NOT NULL` – a fixed-length string of 9 characters, also mandatory. Other attributes like `Bdate` (birthdate) use the `DATE` type, `Salary` uses `DECIMAL(10,2)` for precise monetary values, and `Dno` (department number) is an `INT NOT NULL`.
The statement `PRIMARY KEY (Ssn)` then establishes the `Ssn` as the unique identifier for each employee.

Next is the `CREATE TABLE DEPARTMENT` statement.
Here, `Dname` (department name) is `VARCHAR(15) NOT NULL`, and `Dnumber` (department number) is `INT NOT NULL`. The `Mgr_ssn` (manager's SSN) is `CHAR(9) NOT NULL`, indicating the manager is identified by their SSN.
For the `DEPARTMENT` table, `PRIMARY KEY (Dnumber)` sets the department number as its primary key. `UNIQUE (Dname)` ensures that no two departments can have the same name. A vital part is the `FOREIGN KEY (Mgr_ssn) REFERENCES EMPLOYEE(Ssn)` clause. This ensures that the `Mgr_ssn` listed for a department must correspond to an actual `Ssn` in the `EMPLOYEE` table, meaning the manager must be a valid employee.

Then, we have `CREATE TABLE DEPT_LOCATIONS`.
This table stores department locations. `Dnumber` is an `INT NOT NULL`, and `Dlocation` is `VARCHAR(15) NOT NULL`. The primary key here is a combination: `PRIMARY KEY (Dnumber, Dlocation)`. This means that for any given department, a specific location can only be listed once. The `FOREIGN KEY (Dnumber) REFERENCES DEPARTMENT(Dnumber)` ensures that any department number listed here must be a valid department from the `DEPARTMENT` table.

This slide outlines the creation of these initial tables. The remaining tables of the COMPANY schema are defined in a similar fashion, as we'll see next.

*(Continued on next slide in the original presentation)*

---

### SQL CREATE TABLE data definition statements for defining the COMPANY schema from Figure 5.7 (Fig. 6.1)-continued

Let's continue with the remaining `CREATE TABLE` statements for our COMPANY schema.

Next, we see the `CREATE TABLE PROJECT` statement again, which we've already analyzed. It defines the project's name, number, location, and controlling department, with `Pnumber` as the primary key, `Pname` as unique, and `Dnum` as a foreign key to the `DEPARTMENT` table.

Following that is `CREATE TABLE WORKS_ON`. This is our associative table linking employees to projects.
It includes `Essn` (Employee SSN) as `CHAR(9) NOT NULL`, `Pno` (Project Number) as `INT NOT NULL`, and `Hours` as `DECIMAL(3,1) NOT NULL` to store working hours with one decimal place.
The `PRIMARY KEY (Essn, Pno)` means that an employee can only be listed once for any given project. Then, we have two foreign keys: `FOREIGN KEY (Essn) REFERENCES EMPLOYEE(Ssn)` links to a valid employee, and `FOREIGN KEY (Pno) REFERENCES PROJECT(Pnumber)` links to a valid project. These foreign keys are essential for maintaining the integrity of this many-to-many relationship.

Finally, the `CREATE TABLE DEPENDENT` statement.
This table stores employee dependent information. It has `Essn` (`CHAR(9) NOT NULL`) to link to the employee, `Dependent_name` (`VARCHAR(15) NOT NULL`), and other attributes like `Sex`, `Bdate`, and `Relationship`.
The `PRIMARY KEY (Essn, Dependent_name)` ensures that for any employee, each dependent name must be unique. And, of course, `FOREIGN KEY (Essn) REFERENCES EMPLOYEE(Ssn)` connects each dependent record to an existing employee in the `EMPLOYEE` table.

With these statements, the entire structure of the COMPANY database, including all its tables and the relationships between them, is fully defined. This is the power of SQL's Data Definition Language.

---

<div class="page-break"></div>

## Attribute Data Types and Domains in SQL

When we define our tables using `CREATE TABLE`, choosing the correct **data type** for each attribute is fundamental. The data type dictates what kind of information a column can hold, how it's stored, and what operations can be performed on it. SQL offers a variety of built-in data types.

Let's start our discussion with **Numeric data types**:
*   For **Integer numbers** (whole numbers), common SQL types include:
    *   `INTEGER` or `INT`: This is generally used for standard integer values. For example, if you're storing a count of items or an ID number that doesn't have a fractional part, `INT` is a good choice. It typically uses 4 bytes of storage.
    *   `SMALLINT`: If you know your integer values will always be relatively small (e.g., the number of children someone has, or a rating from 1 to 5), `SMALLINT` can be more efficient. It uses 2 bytes and thus consumes less storage space than `INT`.

*   For **Floating-point (real) numbers**, which are numbers that can have a decimal component, SQL provides:
    *   `FLOAT` or `REAL`: These types are used for numbers where you need to represent fractional values, but absolute precision might not be as critical as with financial calculations. `REAL` often uses 4 bytes. An example could be scientific measurements or scores that aren't strictly whole numbers.
    *   `DOUBLE PRECISION`: This offers more precision than `FLOAT` or `REAL`, typically using 8 bytes. It's suitable for calculations requiring a higher degree of accuracy with decimal numbers.

The slide provides a handy table summarizing these:
*   `SMALLINT` is for small whole numbers, using 2 bytes.
*   `INTEGER` / `INT` is for general whole numbers, using 4 bytes.
*   `REAL` / `FLOAT` is for smaller floating-point numbers (approx. 6-7 decimal digits of precision), using 4 bytes.
*   `DOUBLE PRECISION` is for high-accuracy floating-point numbers (approx. 15-16 decimal digits of precision), using 8 bytes.

Choosing the most appropriate numeric type helps ensure data integrity and can optimize storage and performance.

---

Let's continue our exploration of SQL's basic data types, moving on to **Character-string data types**. These are used to store text.

SQL provides two main categories for character strings:
*   **Fixed length strings**:
    *   Defined using `CHAR(n)` or `CHARACTER(n)`, where `n` is the exact number of characters the string will hold.
    *   If you store a string that is shorter than `n` characters in a `CHAR(n)` column, the database will typically pad it with spaces to reach the length `n`.
    *   `CHAR` is best suited for data where the length is consistent and known, like state abbreviations (e.g., 'CA', 'NY', always 2 characters), or perhaps fixed-length codes.

*   **Varying length strings**:
    *   Defined using `VARCHAR(n)` or `CHAR VARYING(n)` or `CHARACTER VARYING(n)`. Here, `n` specifies the *maximum* number of characters the string can hold.
    *   Unlike `CHAR`, if you store a string shorter than `n` in a `VARCHAR(n)` column, it only stores the actual characters without adding padding spaces. This can save storage space if your text data has highly variable lengths.
    *   `VARCHAR` is generally preferred for text like names, addresses, or descriptions, where the length can differ significantly from one entry to another.

The table on the slide summarizes this well:
*   `CHAR(n)`: Storage is Fixed. Padding is Yes (adds spaces). It's best for fixed-length fields like IDs or codes.
*   `VARCHAR(n)`: Storage is Variable. Padding is No. It's best for variable-length text like names.

Understanding the difference between `CHAR` and `VARCHAR` is key to designing efficient table structures.

---

### Attribute Data Types and Domains in SQL (cont'd.)

Beyond numeric and standard character strings, SQL offers other specialized data types.

*   **Bit-string data types**: These are used to store sequences of bits (0s and 1s).
    *   Similar to character strings, they can be **fixed length**: `BIT(n)` defines a bit string of exactly `n` bits.
    *   Or they can be **varying length**: `BIT VARYING(n)` defines a bit string with a maximum length of `n` bits.
    *   A common type in this category, especially for storing large binary data like images, audio files, or compiled code, is `BLOB`, which stands for **Binary Large Object**. You might see syntax like `BLOB(10G)` indicating a BLOB that can store up to 10 gigabytes of binary data, though the exact syntax and capabilities can vary between database systems.

*   **Boolean data type**:
    *   This type represents truth values. It can hold one of three values: `TRUE`, `FALSE`, or `NULL` (meaning unknown or not applicable). Booleans are very useful for columns that represent flags or conditions, like "IsActive" or "HasOptedIn."

*   **DATE data type**:
    *   The `DATE` type is specifically designed to store calendar dates.
    *   It typically occupies ten positions if represented as a string, often in a standard format like 'YYYY-MM-DD' (e.g., '2023-10-26').
    *   The core components are, of course, `YEAR`, `MONTH`, and `DAY`.
    *   Many Relational Database Management Systems (RDBMSs) provide built-in functions to manipulate dates, format them for display in different ways, or perform calculations with them (like finding the difference between two dates).

These additional types allow for more precise and semantically rich data modeling.

---

### Attribute Data Types and Domains in SQL (cont'd.)

Let's continue with more attribute data types.

*   **Additional data types** often include time-related types beyond just `DATE`:
    *   The **`Timestamp` data type** is very useful as it typically includes both the `DATE` components (year, month, day) and `TIME` components (hour, minute, second).
    *   Furthermore, timestamps often include **fractions of a second** for greater precision, commonly with a minimum of six decimal places for these fractions. This is crucial for logging events or tracking transactions where sub-second accuracy is important.
    *   Some `Timestamp` types also have an optional **`WITH TIME ZONE` qualifier**. This allows the timestamp to store not just the date and time, but also the time zone information, which is essential when dealing with data from different geographical regions.

*   It's also important to know that `DATE`, `TIME`, `Timestamp`, and another related type called `INTERVAL` (which represents a duration of time) can often be **`cast`** or converted to string formats. This is useful for comparison purposes (e.g., comparing a date stored in the database with a date provided as a string) or for displaying these values in a user-friendly way.

These time-based data types are indispensable for any application that needs to track when events occur or manage time-sensitive information.

---

### Attribute Data Types and Domains in SQL (cont'd.)

Now let's talk about two more advanced concepts related to data types and attribute specification in SQL: `Domain` and `TYPE`.

*   **`Domain`**:
    *   In SQL, a `domain` is essentially a **named, user-defined data type**. You can create a domain that encapsulates a base data type along with optional constraints (like `NOT NULL` or `CHECK` constraints) and a default value.
    *   Once a domain is created, you can use its **name when specifying the data type of an attribute** in a `CREATE TABLE` statement. For example, instead of writing `Ssn CHAR(9) NOT NULL CHECK (...)` repeatedly for every SSN column in your database, you could define a domain.
    *   The slide shows an example: `CREATE DOMAIN SSN_TYPE AS CHAR(9);`. After this, in your `CREATE TABLE` statements, you could simply write `Ssn SSN_TYPE;`.
    *   A significant advantage is that it **makes it easier to change the data type or constraints for all attributes that use that domain**. If you need to modify the definition of `SSN_TYPE` (perhaps change its length or add a new check constraint), you only need to alter the domain definition, and the change will propagate to all columns defined using that domain. This is much easier than finding and altering every individual column definition.
    *   Using domains also **improves schema readability and maintainability** by giving a meaningful name to a common type of data.

*   **`TYPE`**:
    *   The `CREATE TYPE` command is used to create **User Defined Types (UDTs)**. This is a feature more closely associated with object-relational databases and object-oriented applications, which we'll explore in more detail in Chapter 12.
    *   UDTs allow you to define complex data structures, potentially with associated methods or behaviors, going beyond the basic atomic data types. For instance, you could create a `TYPE` for an `Address` that itself contains attributes like `Street`, `City`, `ZipCode`.

Domains help with consistency and maintainability for standard data types, while UDTs (created with `CREATE TYPE`) allow for more complex, object-oriented data modeling.

---
<div class="page-break"></div>

## Specifying Constraints in SQL

A critical part of defining a robust and reliable database schema is **specifying constraints**. Constraints are rules that the DBMS enforces to ensure the accuracy, integrity, and consistency of the data stored in the database. SQL provides several ways to define these constraints.

Let's talk about **Basic constraints**:
*   The Relational Model itself, which forms the theoretical basis for SQL databases, defines three fundamental types of integrity constraints, and these are directly supported in SQL:
    *   First, the **`Key constraint`**: This primarily refers to the primary key. A core rule is that a primary key value cannot be duplicated within a table. Each row must have a unique primary key.
    *   Second, the **`Entity Integrity constraint`**: This rule states that a primary key value cannot be `NULL`. Every row in a table must have a primary key value, and that value must be known and present.
    *   Third, **`Referential integrity constraints`**: This concerns foreign keys. The rule here is that a foreign key value must either:
        1.  Match an existing primary key value in the table it references, or
        2.  Be `NULL` (if NULLs are allowed for that foreign key column).
        This ensures that relationships between tables are always valid. You can't, for example, have an order that refers to a non-existent customer.

These three types of constraints are the bedrock of data integrity in relational databases.

---

### Specifying Attribute Constraints

Beyond the fundamental integrity constraints (key, entity, referential), SQL allows us to specify **Other Restrictions on attribute domains** directly when we define columns. These are often called attribute-level or column-level constraints.

*   One common restriction is specifying a **`Default value` of an attribute**.
    *   This is done using the `DEFAULT <value>` clause in a column definition. For example, you might define a column `OrderStatus` with `DEFAULT 'Pending'`. If a new row is inserted into the table without providing a value for `OrderStatus`, the DBMS will automatically assign 'Pending' to it. This is very useful for ensuring that attributes have a sensible initial value if one isn't explicitly provided.

*   Another crucial constraint is ensuring that **`NULL` is not permitted for a particular attribute**.
    *   This is achieved by adding the `NOT NULL` constraint to the column definition. For example, `EmployeeName VARCHAR(100) NOT NULL` means that every employee record must have a name; it cannot be left unspecified.

*   The **`CHECK` clause** provides a powerful way to define more complex, custom validation rules for an attribute's domain.
    *   A `CHECK` constraint specifies a Boolean expression that must evaluate to `TRUE` or `UNKNOWN` (due to NULLs) for any value stored in that column. If the expression evaluates to `FALSE`, the DBMS will reject the insert or update operation.
    *   The slide gives an example: `Dnumber INT NOT NULL CHECK (Dnumber > 0 AND Dnumber < 21);`. This defines `Dnumber` as a mandatory integer. The `CHECK` constraint further restricts its value to be greater than 0 *and* less than 21. So, effectively, this `Dnumber` must be an integer from 1 to 20, inclusive. Any attempt to insert a `Dnumber` like 0, 21, or -5 would be rejected.

These attribute-level constraints allow for fine-grained control over the data that can be entered into each column, further enhancing data quality.

---

### Specifying Key and Referential Integrity Constraints

Let's delve deeper into how we specify two of the most important types of constraints in SQL: **Key constraints** (specifically primary and unique keys) and **Referential Integrity constraints** (foreign keys). These are typically defined as part of the `CREATE TABLE` statement or can be added later using `ALTER TABLE`.

*   The **`PRIMARY KEY` clause** is used to define the primary key of a relation.
    *   It **specifies one or more attributes that collectively make up the primary key**. If the primary key consists of a single attribute, you can often define it inline with the attribute definition.
    *   For example, if `Dnumber` is the sole primary key for a `DEPARTMENT` table, you could write: `Dnumber INT PRIMARY KEY;` directly in the column definition.
    *   If the primary key is composite (made up of multiple attributes), you would typically define it as a separate table-level constraint, like `PRIMARY KEY (Attribute1, Attribute2)`.

*   The **`UNIQUE` clause** is used to specify alternate keys, which are also known as **candidate keys** in the relational model.
    *   A `UNIQUE` constraint ensures that all values in the specified column (or combination of columns) are distinct from one another, though unlike a primary key, a `UNIQUE` constraint *can* allow NULL values (typically, only one NULL is permitted, though this can vary by RDBMS).
    *   For example, if `Dname` (department name) should be unique within the `DEPARTMENT` table, you could specify: `Dname VARCHAR(15) UNIQUE;`. This prevents two departments from having the same name.

These clauses are fundamental for establishing identity and uniqueness within your tables.

---

### Specifying Key and Referential Integrity Constraints (cont'd.)

Now let's focus on the **`FOREIGN KEY` clause**, which is how we establish and enforce referential integrity – the relationships between tables.

*   When you define a `FOREIGN KEY`, you are essentially saying that values in a column (or set of columns) in one table (the referencing or child table) must match values in a candidate key (usually the primary key) of another table (the referenced or parent table).

*   By **default operation**, if an action (like an update to a parent key or a deletion of a parent row) would violate this referential integrity, the RDBMS will **reject the update or deletion on violation**. For example, if you try to delete a department row that still has employees assigned to it (via a foreign key in the `EMPLOYEE` table), the deletion would typically fail to prevent orphaned employee records.

*   However, SQL allows you to specify a **referential triggered action clause** to define what the DBMS should do automatically when a potential violation occurs due to an update on the referenced key or a deletion of a referenced row. These actions provide more sophisticated ways to maintain consistency.
    *   Common options include:
        *   `SET NULL`: If a referenced parent row is deleted or its key is updated, the corresponding foreign key values in the child table are set to `NULL`. This is only possible if the foreign key column allows NULLs.
        *   `CASCADE`: This is a powerful option. If a referenced parent row is deleted, all corresponding child rows are also automatically deleted. If the parent key is updated, the foreign key values in the child rows are automatically updated to match.
        *   `SET DEFAULT`: If a referenced parent row is deleted or its key is updated, the foreign key values in the child table are set to their defined default value. This requires a default value to be specified for the foreign key column.

    *   It's important to note that the action taken by the DBMS for `SET NULL` or `SET DEFAULT` is generally the same whether the triggering event is an `ON DELETE` (from the parent table) or an `ON UPDATE` (of the parent key).

    *   The `CASCADE` option is particularly suitable for "relationship" tables or for entities whose existence is entirely dependent on the parent entity. For example, if you delete an order, you might want all its line items to be automatically deleted using `ON DELETE CASCADE`.

Choosing the correct referential triggered action is a critical design decision that impacts how your database behaves and maintains integrity.

---

### Giving Names to Constraints

When you define constraints in SQL, such as `PRIMARY KEY`, `UNIQUE`, `FOREIGN KEY`, or `CHECK` constraints, you can optionally give them names. This is a very good practice.

*   You can assign a name to a constraint using the **Keyword `CONSTRAINT`** followed by the desired name, and then the constraint definition itself. For example:
    `CONSTRAINT PK_Employee PRIMARY KEY (Ssn)`
    `CONSTRAINT UQ_DepartmentName UNIQUE (Dname)`
    `CONSTRAINT FK_EmpDept FOREIGN KEY (Dno) REFERENCES DEPARTMENT(Dnumber)`
    `CONSTRAINT CK_Salary CHECK (Salary > 0)`

*   Why bother naming constraints?
    *   First, the **name you provide must be unique** within the schema (or sometimes even the database, depending on the RDBMS).
    *   The primary benefit is that it's **useful for later altering or dropping the constraint**. If you need to modify or remove a constraint, it's much easier and clearer to refer to it by its unique name (e.g., `ALTER TABLE EMPLOYEE DROP CONSTRAINT CK_Salary;`) rather than relying on system-generated names, which can be cryptic and vary between database systems.
    *   Named constraints also make error messages from the database much more informative. If a constraint violation occurs, the error message will often include the name of the constraint that was violated, making it easier to diagnose the problem.

So, while optional, explicitly naming your constraints is highly recommended for maintainability and clarity.

---

### Default attribute values and referential integrity triggered action specification (Fig. 6.2)

Figure 6.2 provides some excellent examples illustrating how default attribute values and named referential integrity triggered actions can be specified within `CREATE TABLE` statements. Let's examine the key aspects shown.

Looking at the `CREATE TABLE EMPLOYEE` definition:
*   For the `Dno` (department number) attribute, it's defined as `INT NOT NULL DEFAULT 1`. This is a great example of a default value. It means if a new employee record is inserted and no department number is explicitly provided, the system will automatically assign '1' as their department number. This ensures every employee has a department, even if it's a default one.
*   The slide also showcases named constraints, which is a best practice. For example:
    *   `CONSTRAINT EMPPK PRIMARY KEY (Ssn)` clearly names the primary key constraint for the `EMPLOYEE` table.
    *   `CONSTRAINT EMPSUPERFK FOREIGN KEY (Super_ssn) REFERENCES EMPLOYEE(Ssn) ON DELETE SET NULL ON UPDATE CASCADE`. This defines the foreign key relationship for an employee's supervisor. The `ON DELETE SET NULL` part means if a supervisor's record is removed from the `EMPLOYEE` table, the `Super_ssn` field for all employees who reported to that supervisor will be set to `NULL` (assuming `Super_ssn` allows nulls). The `ON UPDATE CASCADE` means if a supervisor's `Ssn` (their primary key) is ever updated, that new `Ssn` value will automatically propagate to the `Super_ssn` field of their direct reports.
    *   `CONSTRAINT EMPDEPTFK FOREIGN KEY(Dno) REFERENCES DEPARTMENT(Dnumber) ON DELETE SET DEFAULT ON UPDATE CASCADE`. This establishes the link to the `DEPARTMENT` table. If a department is deleted, the `Dno` for employees in that department will revert to the default value specified for `Dno` (which is '1' in this case). If a department's `Dnumber` is updated, this change will also cascade to the `Dno` of its employees.

Now, let's look at the `CREATE TABLE DEPARTMENT` definition:
*   For the `Mgr_ssn` (manager's SSN) attribute, it's defined as `CHAR(9) NOT NULL DEFAULT '000000000'`. This means if a department is created without specifying a manager, a placeholder default SSN value (like '000000000' as shown, or another designated placeholder) will be used.
*   Again, we see named constraints:
    *   `CONSTRAINT DEPTPK PRIMARY KEY (Dnumber)`.
    *   `CONSTRAINT DEPTSK UNIQUE (Dname)`.
    *   `CONSTRAINT DEPTMGRFK FOREIGN KEY (Mgr_ssn) REFERENCES EMPLOYEE(Ssn) ON DELETE SET DEFAULT ON UPDATE CASCADE`. This links the department's manager to a valid employee. If the employee record of a manager is deleted, the `Mgr_ssn` in the `DEPARTMENT` table will be set to its default value. If the manager's `Ssn` is updated, that update will cascade to the `Mgr_ssn` field in the `DEPARTMENT` table.

Finally, in the `CREATE TABLE DEPT_LOCATIONS` definition:
*   We see `FOREIGN KEY (Dnumber) REFERENCES DEPARTMENT(Dnumber) ON DELETE CASCADE ON UPDATE CASCADE`. The `ON DELETE CASCADE` here is quite significant. If a department is deleted from the `DEPARTMENT` table, all its associated location records in `DEPT_LOCATIONS` will automatically be deleted as well. Similarly, an update to a `Dnumber` in `DEPARTMENT` would cascade to `DEPT_LOCATIONS`.

These examples effectively demonstrate how default values ensure completeness and how referential actions like `SET NULL`, `SET DEFAULT`, and `CASCADE` help maintain data integrity automatically when changes occur in related tables.

---

### Specifying Constraints on Tuples Using CHECK

Beyond constraints on individual attributes, SQL also allows us to specify more general constraints that apply to entire **tuples** (or rows) within a relation. This is often done using the `CHECK` clause, but applied at the table level rather than just to a single column.

*   So, **Additional Constraints on individual tuples within a relation are also possible using `CHECK`**. These table-level `CHECK` constraints can involve multiple attributes from the same tuple.

*   These **`CHECK` clauses are typically placed at the end of a `CREATE TABLE` statement**, after all the column definitions and other constraints like primary and foreign keys.

*   The condition specified in a table-level `CHECK` constraint will **apply to each tuple individually** whenever a row is inserted or updated. The operation will only succeed if the `CHECK` condition evaluates to `TRUE` (or `UNKNOWN` if NULLs are involved in the expression in a way that doesn't make it definitively false).

*   The slide provides a good example related to business logic: **A manager's starting date should be after a department's creation date.**
    *   Let's assume our `DEPARTMENT` table has attributes like `Dept_create_date` (when the department was established) and `Mgr_start_date` (when the current manager started).
    *   We could add a table-level constraint like: `CHECK (Dept_create_date <= Mgr_start_date);`
    *   This constraint ensures that for any department record, the manager's start date cannot be earlier than the department's creation date, which makes logical sense.

Table-level `CHECK` constraints are very powerful for enforcing business rules and ensuring the semantic consistency of your data beyond what simple attribute constraints can achieve.

---
<div class="page-break"></div>

## Basic Retrieval Queries in SQL

Alright, we've spent a good amount of time on Data Definition Language (DDL) – creating tables and specifying constraints. Now, let's shift our focus to one of the most common and powerful uses of SQL: **retrieving information from the database**. This is done using Data Manipulation Language (DML) commands, primarily the `SELECT` statement.

*   The **`SELECT` statement** is the cornerstone of data retrieval in SQL. It is the **one basic statement used for retrieving information** from one or more tables in a database. You'll be writing `SELECT` statements constantly when working with SQL.

*   An interesting characteristic of SQL, which sometimes differs from the pure relational model theory, is that **SQL allows a table to have two or more tuples (rows) that are identical in all their attribute values**.
    *   In the strict set-theory based relational model, a relation is a set of tuples, and sets, by definition, do not contain duplicate elements.
    *   SQL, however, by default, treats tables as **multisets** (also sometimes called **bags**). A multiset can contain duplicate elements. This is known as **multiset or bag behavior**.
    *   This means if you run a `SELECT` query, and multiple identical rows satisfy your query conditions, all of them will be returned by default. We'll see later how we can explicitly ask for only unique rows if needed.

Understanding the `SELECT` statement and its behavior with multisets is fundamental to querying databases effectively.

---

### The SELECT-FROM-WHERE Structure of Basic SQL Queries

The most fundamental form of an SQL query for retrieving data revolves around three main clauses: `SELECT`, `FROM`, and `WHERE`. This is often referred to as the **SELECT-FROM-WHERE block**.

*   Let's look at the **basic form of the `SELECT` statement**:

    The structure is:
    `SELECT <attribute list>`
    `FROM   <table list>`
    `WHERE  <condition>;`

    Let's break down what each part means:
    *   The **`attribute list`** following the `SELECT` keyword specifies which columns (attributes) you want to retrieve. You list the names of the columns whose values you are interested in seeing in your results.
    *   The **`table list`** following the `FROM` keyword specifies which table (or tables) the data should be retrieved from. You list the names of the relations that contain the attributes you're selecting or are needed for your conditions.
    *   The **`condition`** following the `WHERE` keyword is optional, but very commonly used. It's a conditional (Boolean) expression that filters the rows. Only the tuples (rows) for which this condition evaluates to `TRUE` will be included in the query result. If you omit the `WHERE` clause, all rows from the specified table(s) are considered.

This SELECT-FROM-WHERE structure forms the backbone of most SQL retrieval queries.

---

### The SELECT-FROM-WHERE Structure of Basic SQL Queries (cont'd.)

Let's elaborate a bit more on the components of the SELECT-FROM-WHERE structure.

*   Within the `WHERE` clause, you'll often use **logical comparison operators** to build your conditions. Standard comparison operators include:
    *   `=` (equals)
    *   `<` (less than)
    *   `<=` (less than or equal to)
    *   `>` (greater than)
    *   `>=` (greater than or equal to)
    *   and `<>` or `!=` (not equal to – both are common, though `<>` is more standard SQL).
    You can combine multiple conditions using logical operators like `AND`, `OR`, and `NOT`.

*   The attributes listed in the `SELECT` clause are often referred to as **projection attributes**. This term comes from relational algebra, where "projection" is the operation of selecting specific columns from a relation. So, these are the attributes whose values you want to see in your result set.

*   The `WHERE` clause defines the **selection condition**.
    *   This is a **Boolean condition that must be true for any retrieved tuple**. If a row from the `FROM` clause satisfies this condition, it's included in the result; otherwise, it's filtered out.
    *   When your query involves multiple relations (i.e., you list more than one table in the `FROM` clause), the selection conditions in the `WHERE` clause will typically include **join conditions**. Join conditions specify how rows from different tables should be combined based on matching values in related columns. We'll dive much deeper into joins in Chapter 8, but it's important to know that the `WHERE` clause is where these are often specified in basic SQL.

Understanding how to construct effective projection attributes and selection conditions is key to writing queries that retrieve exactly the data you need.

---

### Basic Retrieval Queries

Now, let's make this more concrete by looking at some actual query examples based on our COMPANY database schema and the sample data we saw earlier.

First, consider the result table shown for **Query 0**:
It has two columns: `Bdate` and `Address`.
The single row displayed is: `1965-01-09` for `Bdate`, and `731 Fondren, Houston, TX` for `Address`.

**Query 0** itself is stated as: "Retrieve the birth date and address of the employee(s) whose name is 'John B. Smith'."
The SQL for this query, labeled `Q0`, is:
`SELECT Bdate, Address`
`FROM   EMPLOYEE`
`WHERE  Fname='John' AND Minit='B' AND Lname='Smith';`

Let's break this down:
*   `SELECT Bdate, Address`: We are asking for two pieces of information, the birthdate and the address.
*   `FROM EMPLOYEE`: We are looking for this information in the `EMPLOYEE` table.
*   `WHERE Fname='John' AND Minit='B' AND Lname='Smith'`: This is our selection condition. We are filtering the `EMPLOYEE` table to find rows where the first name is 'John', the middle initial is 'B', *and* the last name is 'Smith'. The result shown on the slide is indeed the birthdate and address for this specific employee from our sample data.

Next, let's look at **Query 1**. The slide shows a sample result table with columns `Fname`, `Lname`, and `Address`, listing several employees.
**Query 1** asks: "Retrieve the name and address of all employees who work for the 'Research' department."
The SQL for this, `Q1`, is:
`SELECT Fname, Lname, Address`
`FROM   EMPLOYEE, DEPARTMENT`
`WHERE  Dname='Research' AND Dnumber=Dno;`

Let's analyze `Q1`:
*   `SELECT Fname, Lname, Address`: We want the first name, last name, and address of employees.
*   `FROM EMPLOYEE, DEPARTMENT`: This is interesting! We are now pulling data from *two* tables: `EMPLOYEE` and `DEPARTMENT`. We need information from `EMPLOYEE` (name and address) and information from `DEPARTMENT` (the department name 'Research').
*   `WHERE Dname='Research' AND Dnumber=Dno;`: This `WHERE` clause has two parts connected by `AND`:
    *   `Dname='Research'`: This filters for the 'Research' department from the `DEPARTMENT` table.
    *   `Dnumber=Dno`: This is a **join condition**. It links rows from the `DEPARTMENT` table to rows in the `EMPLOYEE` table where the `Dnumber` (department number in `DEPARTMENT`) matches the `Dno` (department number in `EMPLOYEE`). This is how we find employees belonging to the specified department.

These examples illustrate how the SELECT-FROM-WHERE block is used to formulate specific requests for information.

---

### Basic Retrieval Queries (Contd.)

Let's continue with another example, **Query 2**.
The slide shows a result table for this query with columns: `Pnumber` (Project Number), `Dnum` (Department Number), `Lname` (Last Name of manager), `Address` (of manager), and `Bdate` (Birthdate of manager).
The sample data shows two projects, 10 and 30, both managed by 'Wallace' from department 4.

**Query 2** is: "For every project located in 'Stafford', list the project number, the controlling department number, and the department manager's last name, address, and birth date."

The SQL for this query, `Q2`, is:
`SELECT Pnumber, Dnum, Lname, Address, Bdate`
`FROM   PROJECT, DEPARTMENT, EMPLOYEE`
`WHERE  Dnum=Dnumber AND Mgr_ssn=Ssn AND Plocation='Stafford';`

Let's break down `Q2`:
*   `SELECT Pnumber, Dnum, Lname, Address, Bdate`: These are the five pieces of information we want to retrieve for each qualifying project. Notice `Lname`, `Address`, and `Bdate` here refer to the department *manager's* details.
*   `FROM PROJECT, DEPARTMENT, EMPLOYEE`: This query involves *three* tables! We need `PROJECT` for project information (like `Plocation` and `Pnumber`), `DEPARTMENT` to find the controlling department (`Dnum` links to `Dnumber`) and its manager (`Mgr_ssn`), and `EMPLOYEE` to get the manager's details (`Lname`, `Address`, `Bdate`) using the `Mgr_ssn`.
*   `WHERE Dnum=Dnumber AND Mgr_ssn=Ssn AND Plocation='Stafford';`: This `WHERE` clause has three conditions joined by `AND`:
    *   `Plocation='Stafford'`: This is our primary filter, selecting only projects located in 'Stafford'.
    *   `Dnum=Dnumber`: This is a join condition linking the `PROJECT` table (via its `Dnum` column) to the `DEPARTMENT` table (via its `Dnumber` column). This finds the department controlling the Stafford projects.
    *   `Mgr_ssn=Ssn`: This is another join condition. It links the `DEPARTMENT` table (via its `Mgr_ssn` column) to the `EMPLOYEE` table (via its `Ssn` column). This allows us to find the employee record of the manager for that department.

This query demonstrates how you can combine data from multiple tables using join conditions in the `WHERE` clause to answer more complex questions. The order of conditions in the `WHERE` clause generally doesn't matter for the logical outcome, though the database optimizer might process them in a specific order for efficiency.

---

### Ambiguous Attribute Names

A common situation when writing queries that involve multiple tables is encountering **ambiguous attribute names**. This occurs if two or more tables in your `FROM` clause have columns (attributes) with the exact same name.

*   So, the **same name can be used for two (or more) attributes in different relations**. For example, both an `EMPLOYEE` table and a `CUSTOMER` table might have a column named `Address`. Or, as in our schema, `EMPLOYEE` has `Dno` and `DEPARTMENT` has `Dnumber`, but imagine if both were named `Dept_ID`.

*   There's no issue **as long as the attributes are in different relations** *and you are not trying to use that ambiguous name directly in your query without qualification*.

*   However, if you try to use an attribute name that exists in more than one table listed in your `FROM` clause (e.g., in the `SELECT` list or `WHERE` clause), the DBMS won't know which table's version of that attribute you're referring to. This will result in an error.
    To resolve this ambiguity, you **must qualify the attribute name with the relation (table) name** to prevent ambiguity. You do this by prefixing the attribute name with the table name followed by a period (dot). For example, `TABLE_NAME.ATTRIBUTE_NAME`.

The slide provides an example, `Q1A`, which is a variation of our earlier Query 1.
`Q1A: SELECT Fname, EMPLOYEE.Name, Address`
`     FROM   EMPLOYEE, DEPARTMENT`
`     WHERE  DEPARTMENT.Name='Research' AND`
`            DEPARTMENT.Dnumber=EMPLOYEE.Dnumber;`

Let's analyze this, assuming for the sake of illustration that `EMPLOYEE` had a column named `Name` and also a column named `Dnumber`, and `DEPARTMENT` also had columns named `Name` and `Dnumber`. (In our actual schema, `EMPLOYEE` has `Lname` and `Dno`, and `DEPARTMENT` has `Dname` and `Dnumber`. The slide uses generic names to illustrate the point of ambiguity.)

*   `SELECT Fname, EMPLOYEE.Name, Address`: Here, `Fname` and `Address` are assumed to be unambiguous (perhaps only existing in `EMPLOYEE`). However, if `Name` existed in both, `EMPLOYEE.Name` explicitly tells the DBMS to get the `Name` from the `EMPLOYEE` table.
*   `WHERE DEPARTMENT.Name='Research'`: This qualifies `Name` with `DEPARTMENT`, meaning we are checking the `Name` column of the `DEPARTMENT` table.
*   `AND DEPARTMENT.Dnumber=EMPLOYEE.Dnumber`: This join condition explicitly states we are comparing the `Dnumber` from the `DEPARTMENT` table with the `Dnumber` from the `EMPLOYEE` table.

Qualification is essential whenever ambiguity could arise. It's also often good practice to qualify attribute names even when not strictly necessary if it improves the readability and clarity of your query, especially in complex queries involving many tables.

---

### Aliasing and Renaming

When dealing with qualified attribute names, especially if table names are long, or if you need to refer to the same table multiple times in a single query (a self-join), SQL provides a convenient feature called **aliasing** or using **tuple variables**.

*   **Aliases or tuple variables** allow you to declare alternative, usually shorter, names for your relations (tables) within the scope of a single query. You define these aliases in the `FROM` clause.

The slide gives an example with **Query 8**: "For each employee, retrieve the employee's first and last name and the first and last name of his or her immediate supervisor."
This requires us to access the `EMPLOYEE` table twice: once for the employee's details and once for their supervisor's details (since supervisors are also employees).

The SQL query `Q8` demonstrates this:
`SELECT E.Fname, E.Lname, S.Fname, S.Lname`
`FROM   EMPLOYEE AS E, EMPLOYEE AS S`
`WHERE  E.Super_ssn=S.Ssn;`

Let's break this down:
*   `FROM EMPLOYEE AS E, EMPLOYEE AS S`: This is the key part for aliasing.
    *   `EMPLOYEE AS E` means we are referring to the `EMPLOYEE` table with the alias `E`. So, `E` represents one instance or role of the `EMPLOYEE` table (for the employee).
    *   `EMPLOYEE AS S` means we are referring to the `EMPLOYEE` table *again*, but this time with the alias `S`. `S` represents another instance or role of the `EMPLOYEE` table (for the supervisor).
    *   The `AS` keyword is optional in many SQL dialects, so `FROM EMPLOYEE E, EMPLOYEE S` would often work too.

*   `SELECT E.Fname, E.Lname, S.Fname, S.Lname`: Now we use these aliases to qualify the attributes.
    *   `E.Fname` and `E.Lname` refer to the first and last name from the `E` instance (the employee).
    *   `S.Fname` and `S.Lname` refer to the first and last name from the `S` instance (the supervisor).

*   `WHERE E.Super_ssn=S.Ssn;`: This is the join condition for this self-join. It links an employee (`E`) to their supervisor (`S`) by matching the employee's `Super_ssn` with the supervisor's `Ssn`.

*   The slide also notes that it's a **recommended practice to abbreviate names using aliases** and to **prefix attributes with these aliases when you have the same or similar attribute names coming from multiple tables** (or multiple instances of the same table, as in this self-join). This greatly improves query readability and prevents ambiguity.

Aliasing is a very powerful and commonly used feature in SQL.

---

### Aliasing, Renaming and Tuple Variables (contd.)

Continuing with aliasing and renaming:

*   Not only can you alias table names, but **the attribute names themselves can also be effectively renamed in the output of a query using aliases in the `SELECT` clause**. We saw this earlier with `1.1 * E.Salary AS Increased_sal`. The `AS Increased_sal` renames the calculated column in the result set.

*   The slide also mentions a less common but possible syntax for renaming attributes in the context of a table alias in the `FROM` clause, although this specific syntax for renaming columns *within the `FROM` clause table alias* is not universally supported or as frequently used as column aliasing in the `SELECT` list. The example shown is:
    `EMPLOYEE AS E(Fn, Mi, Ln, Ssn, Bd, Addr, Sex, Sal, Sssn, Dno)`
    This syntax, if supported, would mean that within this query, when referring to the `EMPLOYEE` table via alias `E`, you would use `E.Fn` instead of `E.Fname`, `E.Ln` instead of `E.Lname`, and so on. It's a way to provide short aliases for all columns of a table in one go when you alias the table.

*   The important takeaway here is that the alias `E` (or any other alias you define for a table in the `FROM` clause) acts as a **tuple variable**. A tuple variable is a variable that ranges over the tuples (rows) of the relation it is associated with. So, in our previous query, `E` conceptually iterates through each employee row, and `S` iterates through each potential supervisor row.

*   And as mentioned before, the **keyword "AS" is often optional** when defining table or column aliases in most SQL implementations. So, `EMPLOYEE E` is usually equivalent to `EMPLOYEE AS E`, and `SELECT Salary * 1.1 NewSalary` is equivalent to `SELECT Salary * 1.1 AS NewSalary`. However, using `AS` can sometimes improve readability.

Understanding tuple variables and aliasing is key to writing more complex and readable SQL queries.

<div class="page-break"></div>

Okay, let's continue with the lecture.

---

### Unspecified WHERE Clause and Use of the Asterisk

Now, let's discuss what happens when you write a `SELECT` statement with a **missing `WHERE` clause**, and also how to use the **asterisk (`*`)** as a shorthand in your queries.

*   Regarding a **Missing `WHERE` clause**:
    *   If you write a `SELECT ... FROM ...` query and completely omit the `WHERE` clause, it **indicates no condition on tuple selection**.
    *   The effect of this, when more than one table is listed in the `FROM` clause, is a **`CROSS PRODUCT`** (also known as a Cartesian Product) of the tables involved.
    *   This means the **result is all possible tuple combinations**. Each row from the first table is combined with every row from the second table, and so on if more tables are involved. If table A has `m` rows and table B has `n` rows, their cross product will have `m * n` rows.
    *   This is often *not* what you intend if you're trying to retrieve meaningful related data, as it usually generates a very large, and often meaningless, set of results unless you specifically need all combinations.
    *   In relational algebra, this corresponds directly to the Cartesian Product operation, which we'll discuss in Chapter 8.

The slide shows two queries, Q9 and Q10:
*   **`Q9: SELECT Ssn FROM EMPLOYEE;`**
    This query selects the `Ssn` from the `EMPLOYEE` table. Since there's only one table and no `WHERE` clause, it will simply retrieve the `Ssn` for *all* employees. This is a valid and common use – to get all values of a particular column.

*   **`Q10: SELECT Ssn, Dname FROM EMPLOYEE, DEPARTMENT;`**
    This query selects `Ssn` (from `EMPLOYEE`) and `Dname` (from `DEPARTMENT`). Notice there are two tables in the `FROM` clause but *no `WHERE` clause*. This will result in a cross product. Every employee's `Ssn` will be paired with every department's `Dname`. If you have 100 employees and 10 departments, you'll get 1000 rows in your result, most of which won't represent any meaningful relationship unless that's specifically what you're aiming for (which is rare without further filtering).

So, be very careful when omitting the `WHERE` clause, especially if multiple tables are in the `FROM` clause. Usually, you need a `WHERE` clause to specify join conditions and other filters.

---

### Unspecified WHERE Clause and Use of the Asterisk (cont'd.)

Let's continue with the use of the asterisk (`*`) in SQL queries.

*   You can **specify an asterisk (`*`)** in the `SELECT` list as a shorthand.
    *   When you use `SELECT *`, it means you want to **retrieve all the attribute values (all columns) of the selected tuples (rows)**.

*   If your `FROM` clause involves multiple tables, `SELECT *` will retrieve all columns from *all* the tables listed in the `FROM` clause for the rows that satisfy the `WHERE` condition.
    *   The `*` can also be **prefixed by the relation name** (or its alias) if you want to select all columns from only a *specific* table among several in the `FROM` clause. For example, if you have `FROM EMPLOYEE E, DEPARTMENT D`, you could write `SELECT E.*, D.Dname`. This would retrieve all columns from the `EMPLOYEE` table (aliased as `E`) and only the `Dname` column from the `DEPARTMENT` table (aliased as `D`). If you wrote `SELECT EMPLOYEE.* ...`, it would retrieve all columns from the `EMPLOYEE` table.

Let's look at the examples on the slide:
*   **`Q1C: SELECT * FROM EMPLOYEE WHERE Dno=5;`**
    *   This query selects all columns (`*`) from the `EMPLOYEE` table for those employees where the department number (`Dno`) is 5.

*   **`Q1D: SELECT * FROM EMPLOYEE, DEPARTMENT WHERE Dname='Research' AND Dno=Dnumber;`**
    *   This query selects all columns (`*`) from *both* the `EMPLOYEE` table *and* the `DEPARTMENT` table for rows that satisfy the `WHERE` condition. The condition finds employees who work in the 'Research' department by joining `EMPLOYEE` and `DEPARTMENT` on their respective department number columns (`Dno=Dnumber`) and filtering for `Dname='Research'`. The result will include all employee attributes followed by all department attributes for the matching rows.

*   **`Q10A: SELECT * FROM EMPLOYEE, DEPARTMENT;`**
    *   This query, similar to `Q10` we saw earlier, has `*` in the `SELECT` list and two tables in the `FROM` clause with *no `WHERE` clause*. This will produce a cross product of the `EMPLOYEE` and `DEPARTMENT` tables, and for each resulting combined row, it will display all columns from `EMPLOYEE` followed by all columns from `DEPARTMENT`.

While `SELECT *` is convenient for quick ad-hoc queries or when you genuinely need all columns, in production code or formal reports, it's often better practice to explicitly list the columns you need. This makes your query more readable, maintainable, and less prone to breaking if the table structure changes (e.g., new columns are added). It also avoids retrieving unnecessary data, which can be inefficient.

---

### Tables as Sets in SQL

Now, let's discuss how SQL handles duplicate rows in query results, which relates back to the concept of tables as multisets (or bags) rather than true sets.

*   As we mentioned earlier, **SQL does not automatically eliminate duplicate tuples (rows) in query results** by default. If your query produces multiple identical rows based on the selected columns, all those identical rows will be included in the output.

*   This behavior is particularly important to remember **for aggregate operations** (like `COUNT`, `SUM`, `AVG`, etc., which we'll cover in more detail in Section 7.1.7). When performing aggregations, whether duplicates are included or excluded can significantly affect the result. SQL provides ways to handle duplicates in aggregations.

*   If you *do* want to eliminate duplicate rows from your query result and see only the unique rows, you must explicitly **use the keyword `DISTINCT` in the `SELECT` clause**.
    *   When `DISTINCT` is specified, the database processes the query and then filters out any duplicate rows from the result set before presenting it. **Only distinct (unique) tuples will remain in the result.** The `DISTINCT` keyword applies to the entire row of selected columns; a row is considered a duplicate if all its selected column values match another row's selected column values.

The slide shows **Query 11** and **Query 11A** to illustrate this:
*   **Query 11:** "Retrieve the salary of every employee."
    *   `Q11: SELECT ALL Salary FROM EMPLOYEE;`
    *   The keyword `ALL` here explicitly states the default behavior, which is to include all rows, including duplicates. If multiple employees have the same salary, that salary value will appear multiple times in the result. Since `ALL` is the default, `SELECT Salary FROM EMPLOYEE;` would produce the same result.

*   **Query 11A:** "Retrieve all *distinct* salary values."
    *   `Q11A: SELECT DISTINCT Salary FROM EMPLOYEE;`
    *   By adding the `DISTINCT` keyword, this query will return a list of salary values where each unique salary amount appears only once, regardless of how many employees earn that salary.

Understanding when and how to use `DISTINCT` is crucial for getting the precise results you need from your queries.

---

### Tables as Sets in SQL (cont'd.)

Beyond handling duplicates within a single query's results, SQL also provides **set operations** that allow you to combine the results of two or more `SELECT` statements in ways analogous to mathematical set theory. These operations treat the result sets of the queries as sets (or multisets) of rows.

*   The standard **set operations** in SQL are:
    *   `UNION`: Combines the results of two queries and returns all rows that appear in *either* result, eliminating duplicates (by default).
    *   `EXCEPT` (sometimes `MINUS` in certain SQL dialects like Oracle): Takes the result of the first query and removes any rows that also appear in the result of the second query. It returns rows that are in the first result but not in the second, eliminating duplicates.
    *   `INTERSECT`: Returns only the rows that appear in *both* query results, eliminating duplicates.

*   SQL also provides corresponding **multiset operations** for these, which *do not* eliminate duplicates:
    *   `UNION ALL`: Combines the results of two queries and includes all rows from both, including any duplicates. This is often faster than `UNION` because it doesn't need to perform the duplicate elimination step.
    *   `EXCEPT ALL` and `INTERSECT ALL`: These are less commonly supported or have more complex semantics regarding how duplicates are handled compared to `UNION ALL`. The standard behavior of `EXCEPT` and `INTERSECT` is generally to eliminate duplicates.

*   A very important requirement for using these set operations is **type compatibility**. For two queries to be combined with `UNION`, `EXCEPT`, or `INTERSECT` (or their `ALL` versions):
    *   The `SELECT` lists of the queries must have the **same number of columns**.
    *   The data types of the **corresponding columns must be compatible**. For example, you can't typically `UNION` a column of numbers with a column of character strings directly without some form of conversion. The columns are paired up by their position in the `SELECT` list.

The slide presents **Query 4A** as an example of using `UNION`:
*   **Query 4:** "Make a list of all project numbers for projects that involve an employee whose last name is 'Smith', either as a worker or as a manager of the department that controls the project."

This query requires us to find project numbers from two different scenarios and then combine them.
*   The **first `SELECT` statement** finds project numbers where 'Smith' is a manager of the department controlling the project:
    ` (SELECT DISTINCT Pnumber`
    `  FROM   PROJECT, DEPARTMENT, EMPLOYEE`
    `  WHERE  Dnum=Dnumber AND Mgr_ssn=Ssn AND Lname='Smith')`
    This part joins `PROJECT`, `DEPARTMENT`, and `EMPLOYEE` to find projects controlled by a department managed by someone named 'Smith'. `DISTINCT Pnumber` ensures we only list each such project number once.

*   The **`UNION`** keyword then combines these results with the results of the second `SELECT` statement.

*   The **second `SELECT` statement** finds project numbers where 'Smith' is a worker on the project:
    ` (SELECT DISTINCT Pnumber`
    `  FROM   PROJECT, WORKS_ON, EMPLOYEE`
    `  WHERE  Pnumber=Pno AND Essn=Ssn AND Lname='Smith')`
    This part joins `PROJECT`, `WORKS_ON`, and `EMPLOYEE` to find projects on which an employee named 'Smith' works. Again, `DISTINCT Pnumber` is used.

The `UNION` operation will take all the distinct project numbers from the first query, all the distinct project numbers from the second query, combine them, and then remove any duplicates from the final combined list. So, if a project has 'Smith' as both a worker and as the manager of the controlling department, its project number will only appear once in the final result.

Set operations are incredibly useful for constructing complex queries by breaking them down into simpler, combinable parts.

---

### Substring Pattern Matching and Arithmetic Operators

SQL provides powerful operators for tasks beyond simple equality checks, such as matching parts of strings or performing comparisons based on ranges.

*   The **`LIKE` comparison operator** is specifically used for **string pattern matching** in the `WHERE` clause. It allows you to search for strings that match a certain pattern, rather than just an exact string. `LIKE` uses two special wildcard characters:
    *   The **percent sign (`%`)** replaces an arbitrary number of zero or more characters. For example, `LIKE 'Intro%'` would match 'Introduction', 'Introductory', or 'Intro'. `LIKE '%SQL%'` would match any string containing 'SQL' anywhere within it.
    *   The **underscore (`_`)** replaces a single character. For example, `LIKE '_BC'` would match 'ABC', 'XBC', but not 'ABCC' or 'BC'. `LIKE 'H_me'` would match 'Home' or 'Hame'.

    The slide gives a couple of examples:
    *   `WHERE Address LIKE '%Houston,TX%'`: This condition would find any address that contains the substring 'Houston,TX' anywhere within it.
    *   `WHERE Ssn LIKE '__1__8901';`: This pattern, assuming an SSN is 9 characters, would match SSNs where the third character is '1', the sixth is '8', the seventh is '9', the eighth is '0', and the ninth is '1'. The two underscores at the beginning represent any two characters, and the two underscores after '1' represent any two characters. (The original OCR had spaces, `_ _ 1 _ _ 8901`, which isn't standard; I'm interpreting it as standard SQL wildcards.)

*   Another useful comparison operator is **`BETWEEN`**.
    *   The `BETWEEN ... AND ...` operator is used to check if a value falls within a specified range (inclusive of the start and end values). It's a more readable alternative to writing `value >= lower_bound AND value <= upper_bound`.
    *   The slide gives an example from a hypothetical Query 14:
        `WHERE (Salary BETWEEN 30000 AND 40000) AND Dno = 5;`
        This condition would select employees whose salary is greater than or equal to 30000 *and* less than or equal to 40000, *and* who also work in department number 5. The parentheses around the `BETWEEN` condition are good for clarity, especially when combined with other `AND` or `OR` conditions.

These operators significantly expand the expressiveness of your `WHERE` clauses.

---

### Arithmetic Operations

SQL is not just for retrieving and comparing existing data; you can also perform **arithmetic operations** directly within your queries, typically as part of the `SELECT` list to create calculated columns, or sometimes even in the `WHERE` clause (though less common for complex arithmetic there).

*   SQL supports the **standard arithmetic operators**:
    *   Addition (`+`)
    *   Subtraction (`-`)
    *   Multiplication (`*`)
    *   Division (`/`)
    These operators can be included as part of the `SELECT` list to compute new values based on existing column data.

The slide provides **Query 13** as an example: "Show the resulting salaries if every employee working on the 'ProductX' project is given a 10 percent raise."

The SQL for this is:
`SELECT E.Fname, E.Lname, 1.1 * E.Salary AS Increased_sal`
`FROM   EMPLOYEE AS E, WORKS_ON AS W, PROJECT AS P`
`WHERE  E.Ssn=W.Essn AND W.Pno=P.Pnumber AND P.Pname='ProductX';`

Let's focus on the `SELECT` list:
*   `E.Fname, E.Lname`: We are retrieving the first and last names of the employees.
*   `1.1 * E.Salary AS Increased_sal`: This is where the arithmetic happens.
    *   `E.Salary` refers to the current salary of an employee.
    *   `1.1 * E.Salary` calculates a 10% increase (original salary plus 10% of original salary is equivalent to 110% of original salary, or salary multiplied by 1.1).
    *   `AS Increased_sal` is a column alias. It gives a name ('Increased_sal') to this new calculated column in the result set. Without an alias, the column header for this calculated value might be system-generated and less meaningful.

The `FROM` and `WHERE` clauses join the `EMPLOYEE`, `WORKS_ON`, and `PROJECT` tables to identify only those employees who work on the project named 'ProductX'. The calculation is then applied to their salaries.

This ability to perform calculations directly in SQL queries is very powerful for data analysis and reporting, allowing you to derive new information from your stored data.

---
<div class="page-break"></div>

### Ordering of Query Results

By default, when you execute a `SELECT` query, the order in which the rows are returned is not guaranteed. If you need your results to be presented in a specific sequence – perhaps alphabetically by name, or chronologically by date, or numerically by salary – you must explicitly specify an order. This is achieved using the **`ORDER BY` clause**.

*   The `ORDER BY` clause is your tool for controlling the presentation sequence of your query results.

*   Within this clause, you can specify the sorting direction for each column you're ordering by:
    *   The keyword **`DESC`** (for descending) will sort the result in a high-to-low or Z-to-A fashion for the specified column.
    *   The keyword **`ASC`** (for ascending) explicitly requests an A-to-Z or low-to-high sort. This is actually the default behavior if you don't specify either `ASC` or `DESC`. So, simply saying `ORDER BY Salary` is the same as `ORDER BY Salary ASC`.

*   A key syntactic rule is that the `ORDER BY` clause is **typically placed at the very end of your `SELECT` statement**, following the `SELECT`, `FROM`, and `WHERE` clauses, and also after other clauses like `GROUP BY` or `HAVING` which we will cover later.

The slide shows an example of how you might construct an `ORDER BY` clause: `ORDER BY D.Dname DESC, E.Lname ASC, E.Fname ASC`.
This example illustrates multi-level sorting. The primary sort key is `D.Dname` (department name), which will be sorted in descending order. Then, for any records that have the same department name, a secondary sort will be applied on `E.Lname` (employee last name) in ascending order. And if both the department name and employee last name are the same for some records, a tertiary sort will be done on `E.Fname` (employee first name), also in ascending order. This allows for very fine-grained control over the final presentation of your data.

---

### Basic SQL Retrieval Query Block

So, to bring together the fundamental pieces of an SQL query for fetching data, we can think of a **Basic SQL Retrieval Query Block**. This block represents the core structure you'll use most often.

As you can see on the slide, this basic block consists of several key clauses:
*   It always starts with the **`SELECT` clause**, where you list the attributes or columns whose values you wish to retrieve. This could be specific column names, calculations, or even an asterisk (`*`) to denote all columns.
*   Next is the **`FROM` clause**, which is also mandatory. This clause specifies the table or tables from which the data will be drawn.
*   Following that, we have the **`WHERE` clause**, which is optional. If included, it contains a condition that filters the rows. Only rows that satisfy this condition will be considered for the result set. This is where you'll put your filtering logic and, importantly, your join conditions when querying multiple tables.
*   And finally, the optional **`ORDER BY` clause** can be used to sort the rows in the final result set based on the values in one or more specified columns.

This SELECT-FROM-WHERE-ORDER BY sequence forms the backbone of most data retrieval operations in SQL. While there are other clauses we'll add later for more advanced querying, mastering this fundamental structure is absolutely essential.

---
<div class="page-break"></div>

## INSERT, DELETE, and UPDATE Statements in SQL

Thus far, our primary focus has been on how to retrieve data using the `SELECT` statement. However, SQL is much more than just a query language; it also provides powerful commands for modifying the data stored within your database.

There are **three core commands used to modify the database's content**. These are fundamental Data Manipulation Language (DML) statements:
*   The **`INSERT`** command is used to add entirely new rows, or tuples, into a table.
*   The **`DELETE`** command is used to remove existing rows from a table.
*   And the **`UPDATE`** command is used to change or modify the values of data within existing rows in a table.

Let's briefly elaborate:
*   When you use **`INSERT`**, you're essentially creating a new record and adding it to the specified table. You'll provide the values for each column of this new record.
*   With **`UPDATE`**, you're targeting existing records that meet certain criteria (specified in a `WHERE` clause) and then changing the values in one or more of their columns (specified in a `SET` clause).
*   With **`DELETE`**, you're also targeting existing records based on a `WHERE` clause, but instead of changing their values, you're removing those records entirely from the table. (The slide mentions DELETE "may also update a number of tuples," which is a slight misphrasing. DELETE *removes* tuples, thereby "updating" the state of the table by having fewer rows.)

These three commands—`INSERT`, `UPDATE`, and `DELETE`—are the essential tools for managing the lifecycle of data within your database tables.

---

### INSERT

Let's begin our closer look at data modification commands with the **`INSERT` statement**. This is how we introduce new data into our tables.

*   In its most common and **simplest form, the `INSERT` statement is used to add one new tuple, or row, to a specified relation, or table**.

*   When you're providing the data for this new row, a common way is to list the **attribute values in the exact same order that the attributes (columns) were defined in the `CREATE TABLE` command**. Alternatively, and often more robustly, you can explicitly list the column names you're inserting into, followed by their corresponding values; this makes your `INSERT` statement less dependent on the table's column order.

*   It's crucial to understand that as you attempt to insert data, the database automatically enforces **constraints on data types**. For instance, you cannot insert a text string like "hello" into a column defined as an integer. The database will reject such an attempt.

*   Furthermore, and very importantly, **any integrity constraints that were defined as part of the Data Definition Language (DDL)** – when the table was created or altered – **are strictly enforced**. This includes:
    *   `NOT NULL` constraints: You must provide a value for any column marked `NOT NULL`, unless that column has a `DEFAULT` value defined.
    *   `PRIMARY KEY` and `UNIQUE` constraints: The values you're inserting cannot violate the uniqueness requirements of these keys. You can't insert a row that would create a duplicate primary key.
    *   `FOREIGN KEY` constraints: If you're inserting a value into a foreign key column, that value must either already exist in the primary key column of the referenced "parent" table, or it must be `NULL` (if the foreign key column itself permits `NULL`s).
    *   `CHECK` constraints: Any values being inserted must satisfy the conditions defined in `CHECK` constraints for those columns or for the table as a whole.

If the data you're trying to insert violates any of these rules, the `INSERT` operation will typically fail, and the database will usually return an error message explaining which constraint was violated. This is how the database maintains its integrity.

---

### The INSERT Command

Let's examine the syntax and see some examples of the `INSERT` command in practice.

*   A common way to use `INSERT` is to **specify the relation name and then provide a list of values for the new tuple**. When using this form, you must supply all values, including any `NULL`s (if those columns allow nulls), and these values must be in the same order as the columns in the table definition.

    The slide shows example `U1`, which intends to insert a new record into the `EMPLOYEE` table. The `VALUES` clause would contain a list of data like 'Richard', 'K', 'Marini', an SSN, a birthdate like '1962-12-30', an address, sex, salary, supervisor's SSN, and department number, all corresponding to the `EMPLOYEE` table's columns in their defined order. This statement would attempt to add one complete employee record.

*   Another very powerful variation of the `INSERT` statement allows you to **insert multiple tuples into a table where the data for these new rows comes from the result of a `SELECT` query**. This is incredibly useful for tasks like populating a summary table, copying data between tables, or archiving records.

    Example `U3B` on the slide illustrates this `INSERT ... SELECT` form. It's inserting data into a table named `WORKS_ON_INFO`.
    The statement specifies the target columns in `WORKS_ON_INFO`: `(Emp_name, Proj_name, Hours_per_week)`. This is a good practice as it makes the insert independent of the column order in `WORKS_ON_INFO` and clearly shows which source data maps to which target column.
    The data itself comes from a `SELECT` query that joins the `PROJECT`, `WORKS_ON`, and `EMPLOYEE` tables to retrieve an employee's last name, the project's name, and the hours worked.
    So, for every row returned by this `SELECT` query, a new row will be inserted into `WORKS_ON_INFO`, with `E.Lname` going into `Emp_name`, `P.Pname` into `Proj_name`, and `W.Hours` into `Hours_per_week`.

This `INSERT ... SELECT` structure is highly efficient for moving and transforming sets of data within the database.

---

### BULK LOADING OF TABLES

When we need to load a substantial amount of data into our tables – perhaps from external files, data feeds, or other systems – we often talk about **bulk-loading**. SQL and database systems provide mechanisms to handle this efficiently.

*   The `INSERT ... SELECT` statement we just discussed is one way to perform a kind of bulk-loading, where the source is another query result within the same database.

*   The slide also mentions a scenario where a **new table, say `TNEW`, can be created with an identical structure to an existing table `T`**, and then populated. Some SQL dialects offer specific syntax for this, perhaps using a `LIKE` keyword to copy the structure and then a mechanism to load data, possibly even as part of the table creation statement.

The slide presents an **EXAMPLE** with specific syntax, which might be particular to certain RDBMS environments:
It shows a `CREATE TABLE D5EMPS LIKE EMPLOYEE` statement, followed by a `SELECT` query in parentheses that retrieves all columns for employees in department 5, and then a `WITH DATA` clause.
The *intent* of such a statement, regardless of precise syntax variations across database systems, is twofold:
1.  `CREATE TABLE D5EMPS LIKE EMPLOYEE`: This part aims to create a new table named `D5EMPS` that mirrors the column structure (names, data types, possibly some constraints) of the existing `EMPLOYEE` table.
2.  The `(SELECT ... WHERE E.Dno=5) WITH DATA;` part indicates that this newly created `D5EMPS` table should immediately be populated with the rows returned by the `SELECT` query – specifically, all employee records where the department number is 5.

A very common and more standard SQL approach to achieve a similar outcome – creating a new table and populating it based on a query – is the `CREATE TABLE AS SELECT` (often abbreviated as CTAS) statement. For example:
`CREATE TABLE D5EMPS AS SELECT * FROM EMPLOYEE WHERE Dno=5;`
This single statement would create the `D5EMPS` table with columns matching the `SELECT *` from `EMPLOYEE`, and then insert all employees from department 5 into it.

The core idea is that SQL provides robust ways to not only insert single rows but also to efficiently create and populate tables with large volumes of data, which is essential for many database operations like data migration, setting up analytical environments, or creating backups of specific data subsets.

---

### DELETE

Next, let's discuss the **`DELETE` statement**. This is the SQL command used to remove existing tuples, or rows, from a table.

*   The fundamental purpose of the `DELETE` statement is to **remove one or more rows from a specified table**.

*   Critically, a `DELETE` statement almost always **includes a `WHERE`-clause. This clause specifies the condition that determines which rows should be deleted**. Only rows that satisfy this condition will be removed. If you omit the `WHERE`-clause entirely, the `DELETE` statement will attempt to remove *all* rows from the table. This is a very significant action and should be performed with extreme caution.

*   When you execute a `DELETE` statement, the database system will enforce **referential integrity constraints**.
    *   For instance, if you try to delete a row from a "parent" table (e.g., a department in the `DEPARTMENT` table), but there are still rows in a "child" table (e.g., employees in the `EMPLOYEE` table) that reference that parent row via a foreign key, the delete operation might be disallowed by default to prevent "orphaned" records in the child table.
    *   However, if specific referential actions like `ON DELETE CASCADE` or `ON DELETE SET NULL` were defined for that foreign key relationship, the database would handle it accordingly – either by also deleting the referencing child rows (cascade) or by setting the foreign key values in the child rows to `NULL`.

*   A standard `DELETE` statement operates on **only *one table* at a time**. The syntax is `DELETE FROM table_name ...`. You cannot typically list multiple tables after `DELETE FROM` to remove rows from several tables in a single basic command. (Cascading deletes triggered by foreign key constraints are an exception to this, as they can cause deletions in other related tables.)

*   As emphasized, if the **`WHERE`-clause is missing, the statement implies that *all tuples* in the specified table are to be deleted**. The table's structure (its columns and definitions) will remain, but it will contain no data. This is why it's so important to be careful with `DELETE` statements. Some database systems offer a `TRUNCATE TABLE` command, which is often a faster way to remove all rows from a table, but it typically has different transactional behavior and may not fire `DELETE` triggers.

*   The **number of tuples actually deleted depends entirely on how many rows in the table satisfy the condition specified in the `WHERE`-clause**. This could range from zero rows (if no rows match) to all rows in the table.

The `DELETE` statement is conceptually simple but has significant power. Always being precise with your `WHERE` clause is paramount.

---

### The DELETE Command

Let's look at some practical examples of the `DELETE` command to solidify our understanding. Remember, this command removes entire rows from a table based on specified criteria.

*   The core function of `DELETE` is to **remove tuples from a relation**.
*   It uses a **`WHERE` clause to select which tuples to delete**, and the number of rows affected will depend on how many rows match that condition.

The slide presents several examples, labeled `U4A` through `U4D`, all operating on an `EMPLOYEE` table:

*   Consider **`U4A: DELETE FROM EMPLOYEE WHERE Lname='Brown';`**
    This statement targets the `EMPLOYEE` table. The `WHERE` clause specifies that any row where the `Lname` (last name) attribute is 'Brown' should be deleted. If there are multiple employees with the last name 'Brown', all of them will be removed. If no employee has that last name, the statement will execute successfully but affect zero rows.

*   Next, **`U4B: DELETE FROM EMPLOYEE WHERE Ssn=...;`** (referring to a specific Social Security Number)
    This statement would delete a row from the `EMPLOYEE` table where the `Ssn` column matches a particular Social Security Number provided in the query. Since `Ssn` is the primary key, this operation is designed to delete at most one row – precisely one if an employee with that specific SSN exists in the table.

*   Then, **`U4C: DELETE FROM EMPLOYEE WHERE Dno=5;`**
    This statement will remove all rows from the `EMPLOYEE` table for employees whose department number (`Dno`) is 5. If department 5 has several employees, all their records will be deleted by this single command.

*   Finally, **`U4D: DELETE FROM EMPLOYEE;`**
    This is the most impactful version. Notice the complete **absence of a `WHERE` clause**. This command instructs the database to delete **all rows** from the `EMPLOYEE` table, effectively emptying it of all its data. The table structure itself will remain, but it will contain no records. This command must be used with extreme caution, as it can lead to irreversible data loss if not intended.

These examples clearly demonstrate how the `WHERE` clause is used to precisely target the rows for deletion. It is always critical to verify your `WHERE` clause before executing a `DELETE` statement, especially in a live database environment.

---

### UPDATE

The third fundamental data modification command in SQL that we'll discuss is **`UPDATE`**. This statement is used to modify the existing data *within* one or more selected tuples or rows in a table. Unlike `INSERT` which adds new rows, or `DELETE` which removes rows, `UPDATE` changes the content of rows that are already present.

*   The `UPDATE` statement is specifically **used to modify the attribute values of one or more selected tuples**.

*   Just like the `DELETE` statement, an `UPDATE` statement almost always includes a **`WHERE`-clause. This clause is crucial as it selects the specific tuples (rows) that are to be modified**. If you omit the `WHERE` clause, the `UPDATE` statement will attempt to modify *all rows* in the table, which is rarely the desired outcome and can cause widespread incorrect data changes.

*   In addition to the `WHERE` clause, an `UPDATE` statement requires an **additional `SET`-clause. The `SET`-clause is where you specify which attributes (columns) are to be modified and what their new values should be**. You can update a single column or multiple columns within the same `SET` clause for the targeted rows.

*   An important characteristic of the `UPDATE` command is that **each command modifies tuples *in the same relation*** – that is, the table specified immediately after the `UPDATE` keyword. You typically cannot update columns in multiple tables with a single, standard `UPDATE` statement. (However, updates can trigger actions in other tables via database triggers or if foreign keys are defined with `ON UPDATE CASCADE`.)

*   And, as with `INSERT` and `DELETE` operations, any **referential integrity constraints (and other constraints like `CHECK` or `NOT NULL`) that were defined as part of the DDL specification are strictly enforced** during an `UPDATE`. For example, you cannot update a foreign key column to a value that doesn't exist in the referenced parent table, nor can you update a primary key to a value that already exists in another row, or change a `NOT NULL` column to `NULL`.

The `UPDATE` statement is indispensable for keeping the information in your database current, correcting errors, or reflecting changes in the real-world entities your database models.

---

### UPDATE (contd.)

Let's look at a practical example of the `UPDATE` statement to see how it works.

*   The slide provides an **Example**: "Change the location and controlling department number of project number 10 to 'Bellaire' and 5, respectively."

The SQL for this task, labeled `U5`, is structured as follows:
It begins with `UPDATE PROJECT`, indicating that the `PROJECT` table is the target for our modifications.
Next, the `SET` clause specifies the changes: `SET PLOCATION = 'Bellaire', DNUM = 5`. This means we want to set the `PLOCATION` column to the text value 'Bellaire', and simultaneously set the `DNUM` column to the integer value 5 for the selected row(s). Notice multiple column assignments in the `SET` clause are separated by commas.
Finally, the `WHERE` clause, `WHERE PNUMBER=10`, identifies exactly which row (or rows, though `PNUMBER` is typically a primary or unique key, so it should target one specific project) should receive these updates. Only the project whose `PNUMBER` is 10 will have its location changed to 'Bellaire' and its department number changed to 5.

If a project with `PNUMBER=10` exists, its record will be updated accordingly. If no such project exists, the `UPDATE` statement will execute without error but will not affect any rows. This example shows a targeted update to specific columns of a specific row.

---

### UPDATE (contd.)

Here's another, slightly more complex example of an `UPDATE` statement. This one demonstrates how to update rows based on a condition derived from another table (using a subquery) and also how a column can be updated based on its own current value.

*   The **Example** given is: "Give all employees in the 'Research' department a 10% raise in salary."

The SQL query for this, labeled `U6`, is constructed as:
It starts with `UPDATE EMPLOYEE`, signifying that we're making changes to the `EMPLOYEE` table.
The `SET` clause is `SET SALARY = SALARY * 1.1`. This is where the salary modification happens. For each selected employee, their current `SALARY` (the `SALARY` on the right side of the equals sign) is multiplied by 1.1 (which calculates a 10% increase), and this new calculated value becomes the new `SALARY` (the `SALARY` on the left side).
The `WHERE` clause determines which employees get this raise: `WHERE DNO IN (SELECT DNUMBER FROM DEPARTMENT WHERE DNAME='Research');`. This clause uses a subquery. The inner `SELECT DNUMBER FROM DEPARTMENT WHERE DNAME='Research'` first identifies the department number(s) for all departments named 'Research'. Then, the outer `WHERE DNO IN (...)` condition ensures that only employees whose `DNO` (department number in the `EMPLOYEE` table) matches one of these 'Research' department numbers will have their salaries updated.

The slide correctly points out a key aspect of the `SET SALARY = SALARY * 1.1` logic:
*   **In this request, the modified `SALARY` value depends on the original `SALARY` value in each tuple.**
    *   The reference to the **`SALARY` attribute on the right side of the `=`** (in the expression `SALARY * 1.1`) refers to the **old `SALARY` value *before* the modification is applied** for that specific row.
    *   The reference to the **`SALARY` attribute on the left side of the `=`** refers to the **column that will receive the new `SALARY` value *after* the calculation and modification.**
The database system effectively fetches the current salary, performs the calculation, and then stores the result back into the salary column for each employee who meets the `WHERE` clause criteria.

This example effectively shows how `UPDATE` can be used for more sophisticated data modifications, including conditional updates based on related tables and calculations using existing column values.

---
<div class="page-break"></div>

## Additional Features of SQL

Thus far in this chapter, we've covered the fundamental building blocks of SQL: Data Definition Language (DDL) for creating tables and defining constraints, and basic Data Manipulation Language (DML) for `SELECT`ing, `INSERT`ing, `UPDATE`ing, and `DELETE`ing data. However, SQL is a very rich and extensive language, offering many more features that significantly enhance its power and utility. We will explore these in subsequent chapters.

The slide highlights several categories of these **Additional Features of SQL**:

*   Firstly, there are advanced **Techniques for specifying complex retrieval queries**, which we will delve into in Chapter 7. This includes using aggregate functions like `COUNT`, `SUM`, `AVG`, `MAX`, and `MIN` to perform calculations across sets of rows; grouping data using the `GROUP BY` clause; filtering these groups with the `HAVING` clause; writing more sophisticated nested queries or subqueries; and mastering various types of join operations beyond the simple joins we've hinted at. These capabilities are essential for complex data analysis and reporting.

*   Another crucial area is **Writing programs in various programming languages that include SQL statements**. Databases are typically accessed by applications, and SQL provides several ways to bridge this gap:
    *   Concepts like **Embedded SQL** (where SQL is written directly within host language code like C++ or Java and processed by a precompiler) and **Dynamic SQL** (where SQL queries are constructed and executed by the application at runtime) are important.
    *   We'll also look at standard APIs like **SQL/CLI (Call Level Interface)** and its widely adopted predecessor/implementation **ODBC (Open Database Connectivity)**. These provide a standardized way for applications to communicate with different database systems.
    *   **SQL/PSM (Persistent Stored Modules)** allows for the creation of procedures and functions directly within the database, which can encapsulate business logic and be called by applications. We'll cover these programming aspects in more detail in Chapter 10.

*   SQL also provides a **Set of commands for specifying physical database design parameters, file structures for relations, and access paths**.
    *   While `CREATE TABLE` defines the logical structure, database administrators often need tools to optimize how data is physically stored and accessed for performance.
    *   A prime example is the **`CREATE INDEX`** command. Indexes are special lookup structures that the database can use to speed up data retrieval operations, much like an index in a book helps you find information quickly. We'll discuss indexing strategies in Chapter 17.

These features show that SQL extends far beyond just basic data handling, providing a comprehensive toolkit for database management, development, and optimization.

---

### Additional Features of SQL (cont'd.)

Let's continue exploring the breadth of SQL's additional features, which demonstrate its comprehensive nature as a database language.

*   **Transaction control commands (which we'll cover in Chapter 20)**: These are absolutely vital for ensuring the reliability and consistency of your database, especially in environments where multiple users or processes are accessing and modifying data concurrently. SQL provides commands like `COMMIT`, to make a series of changes permanent, and `ROLLBACK`, to undo a series of changes if something goes wrong. Understanding transactions is fundamental to building robust database applications.

*   **Specifying the granting and revoking of privileges to users (detailed in Chapter 30)**: Database security is a major concern. SQL includes robust mechanisms for controlling who can access what data and what operations they are allowed to perform. This is managed through commands like `GRANT`, which assigns specific permissions (e.g., the ability to `SELECT` from a table, or `INSERT` new data) to users or roles, and `REVOKE`, which removes those permissions. This allows for fine-grained access control.

*   **Constructs for creating triggers (discussed in Chapter 26)**: Triggers are a powerful feature where you can define procedural code (a special kind of stored procedure) that is automatically executed by the database system in response to certain data modification events – specifically, `INSERT`, `UPDATE`, or `DELETE` operations on a particular table. Triggers can be used to enforce complex business rules, automatically update related data, maintain audit logs, or even prevent certain operations under specific conditions.

*   The evolution of relational databases has led to **Enhanced relational systems, often known as object-relational database systems**. These systems extend the traditional relational model with object-oriented features. For example, they might allow you to **define relations conceptually as classes** and support **Abstract Data Types (ADTs)**. In SQL, these ADTs are often referred to as **User Defined Types (UDTs)** and are created using the **`CREATE TYPE`** command. This allows for the definition of more complex, custom data structures beyond the standard built-in types, which can be very useful for modeling complex real-world entities. We'll explore these object-relational features in Chapter 12.

*   Finally, SQL is not a static language; it continually evolves to integrate and support **New technologies** and data paradigms. For instance, modern versions of SQL often include enhanced support for:
    *   Working with **XML (Extensible Markup Language) data (as covered in Chapter 13)**, which might involve storing XML documents directly in the database, querying their content using XPath-like expressions, and generating XML output from relational data.
    *   And features to facilitate **OLAP (Online Analytical Processing) (which we'll look at in Chapter 29)**. OLAP involves performing complex analytical queries over large datasets, typically in the context of data warehouses and business intelligence. SQL has incorporated functions and extensions to better support these kinds of analytical workloads.

This overview should give you a sense that the basic SQL we've learned in this chapter is just the starting point for a very powerful and versatile language.

---
<div class="page-break"></div>

## Summary

Let's take a few moments to summarize the key concepts and commands we've covered in this chapter on Basic SQL.

*   We've established that **SQL** is indeed a **Comprehensive language specifically designed for relational database management**. It's not just a query tool but a full-fledged language for defining, manipulating, and controlling relational databases.

*   Its broad capabilities encompass:
    *   **Data definition**, which includes creating and altering the structure of database objects like schemas and tables.
    *   Formulating **queries** to retrieve data using the `SELECT` statement.
    *   Performing **updates** to the data through `INSERT`, `DELETE`, and `UPDATE` commands.
    *   **Constraint specification** to enforce data integrity and business rules.
    *   And **View definition**, which allows for creating virtual tables based on stored queries (though we've only touched on this briefly here).

*   More specifically, in this chapter, we have **Covered**:
    *   The fundamental **Data definition commands for creating tables**, with a deep dive into the `CREATE TABLE` statement, including how to define columns and their associated data types.
    *   The various **Commands and clauses for constraint specification**, such as defining primary keys, unique keys, foreign keys, and attribute-level constraints like `NOT NULL`, `DEFAULT`, and `CHECK`.
    *   How to write **Simple retrieval queries** using the core SELECT-FROM-WHERE block, and also how to use the `ORDER BY` clause to sort results. We also touched upon handling ambiguous attribute names with aliasing, using the asterisk for selecting all columns, and eliminating duplicate results with the `DISTINCT` keyword.
    *   And, of course, the three essential **Database update commands**: `INSERT` for adding new rows, `DELETE` for removing rows, and `UPDATE` for modifying existing rows.

This chapter has aimed to provide you with a solid foundation in the basics of SQL. The commands and concepts introduced here – `CREATE TABLE`, `SELECT`, `INSERT`, `UPDATE`, `DELETE`, and the various ways to define constraints – are the ones you will use most frequently when interacting with relational databases. Continued practice in writing and understanding these SQL statements is the key to developing proficiency.

This concludes our lecture on Basic SQL. Thank you for your attention.

<div class="page-break"></div>